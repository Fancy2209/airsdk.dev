"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[22472],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),d=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=d(e.components);return o.createElement(s.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(t),u=a,g=p["".concat(s,".").concat(u)]||p[u]||m[u]||i;return t?o.createElement(g,r(r({ref:n},c),{},{components:t})):o.createElement(g,r({ref:n},c))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,r[1]=l;for(var d=2;d<i;d++)r[d]=t[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},98885:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var o=t(87462),a=(t(67294),t(3905));const i={},r="Asynchronous decoding of bitmap images",l={unversionedId:"development/display/working-with-bitmaps/asynchronous-decoding-of-bitmap-images",id:"development/display/working-with-bitmaps/asynchronous-decoding-of-bitmap-images",title:"Asynchronous decoding of bitmap images",description:"When you work with bitmap images, you can asynchronously decode and load the",source:"@site/docs/development/display/working-with-bitmaps/asynchronous-decoding-of-bitmap-images.md",sourceDirName:"development/display/working-with-bitmaps",slug:"/development/display/working-with-bitmaps/asynchronous-decoding-of-bitmap-images",permalink:"/docs/development/display/working-with-bitmaps/asynchronous-decoding-of-bitmap-images",draft:!1,editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-bitmaps/asynchronous-decoding-of-bitmap-images.md",tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Working with bitmaps",permalink:"/docs/development/display/working-with-bitmaps/"},next:{title:"Basics of working with bitmaps",permalink:"/docs/development/display/working-with-bitmaps/basics-of-working-with-bitmaps"}},s={},d=[],c={toc:d},p="wrapper";function m(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"asynchronous-decoding-of-bitmap-images"},"Asynchronous decoding of bitmap images"),(0,a.kt)("p",null,"When you work with bitmap images, you can asynchronously decode and load the\nbitmap images to improve your application's perceived performance. Decoding a\nbitmap image asynchronously can take the same time as decoding the image\nsynchronously in many cases. However, the bitmap image gets decoded in a\nseparate thread before the associated ",(0,a.kt)("inlineCode",{parentName:"p"},"Loader")," object sends the ",(0,a.kt)("inlineCode",{parentName:"p"},"COMPLETE"),"\nevent. Hence, you can asynchronously decode larger images after loading them."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ImageDecodingPolicy")," class in the ",(0,a.kt)("inlineCode",{parentName:"p"},"flash.system")," package, allows you to\nspecify the bitmap loading scheme. The default loading scheme is synchronous."),(0,a.kt)("table",null,(0,a.kt)("thead",null,(0,a.kt)("tr",null,(0,a.kt)("th",null,(0,a.kt)("p",null,"Bitmap Decoding Policy")),(0,a.kt)("th",null,(0,a.kt)("p",null,"Bitmap Loading Scheme")),(0,a.kt)("th",null,(0,a.kt)("p",null,"Description")))),(0,a.kt)("tbody",null,(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("p",null,(0,a.kt)("samp",null,"ImageDecodingPolicy.ON_DEMAND"))),(0,a.kt)("td",null,(0,a.kt)("p",null,"Synchronous")),(0,a.kt)("td",null,(0,a.kt)("p",null,"Loaded images are decoded when the image data is accessed."),(0,a.kt)("p",null,"Use this policy to decode smaller images. You can also use this policy when your application does not rely on complex effects and transitions."))),(0,a.kt)("tr",null,(0,a.kt)("td",null,(0,a.kt)("p",null,(0,a.kt)("samp",null,"ImageDecodingPolicy.ON_LOAD"))),(0,a.kt)("td",null,(0,a.kt)("p",null,"Asynchronous")),(0,a.kt)("td",null,(0,a.kt)("p",null,"Loaded images are decoded on load, before the",(0,a.kt)("samp",null,"COMPLETE"),"event is dispatched."),(0,a.kt)("p",null,"Ideal for larger images (greater than 10 MP). When you are developing AIR-based mobile applications with page transitions, use this bitmap loading policy to improve your application's perceived performance."))))),(0,a.kt)("p",null,"Note: If the file being loaded is a bitmap image and the decoding policy used is\n",(0,a.kt)("inlineCode",{parentName:"p"},"ON_LOAD"),", the image is decoded asynchronously before the ",(0,a.kt)("inlineCode",{parentName:"p"},"COMPLETE")," event is\ndispatched."),(0,a.kt)("p",null,"The following code shows the usage of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ImageDecodingPolicy")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'var loaderContext:LoaderContext = new LoaderContext();\nloaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD\nvar loader:Loader = new Loader();\nloader.load(new URLRequest("https://www.adobe.com/myimage.png"), loaderContext);\n')),(0,a.kt)("p",null,"You can still use ",(0,a.kt)("inlineCode",{parentName:"p"},"ON_DEMAND")," decoding with ",(0,a.kt)("inlineCode",{parentName:"p"},"Loader.load()")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"Loader.loadBytes()")," methods. However, all the other methods that take a\n",(0,a.kt)("inlineCode",{parentName:"p"},"LoaderContext")," object as an argument, ignore any ",(0,a.kt)("inlineCode",{parentName:"p"},"ImageDecodingPolicy")," value\npassed."),(0,a.kt)("p",null,"The following example shows the difference in decoding a bitmap image\nsynchronously and asynchronously:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'package\n{\n    import flash.display.Loader;\n    import flash.display.Sprite;\n    import flash.events.Event;\n    import flash.net.URLRequest;\n    import flash.system.ImageDecodingPolicy;\n    import flash.system.LoaderContext;\n\n    public class AsyncTest extends Sprite\n    {\n        private var loaderContext:LoaderContext;\n        private var loader:Loader;\n        private var urlRequest:URLRequest;\n        public function AsyncTest()\n        {\n            //Load the image synchronously\n            loaderContext = new LoaderContext();\n            //Default behavior.\n            loaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_DEMAND;\n            loader = new Loader();\n            loadImageSync();\n\n            //Load the image asynchronously\n            loaderContext = new LoaderContext();\n            loaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD;\n            loader = new Loader();\n            loadImageASync();\n        }\n\n        private function loadImageASync():void{\n            trace("Loading image asynchronously...");\n            urlRequest = new URLRequest("https://www.adobe.com/myimage.png");\n            urlRequest.useCache = false;\n            loader.load(urlRequest, loaderContext);\n            loader.contentLoaderInfo.addEventListener\n                (Event.COMPLETE, onAsyncLoadComplete);\n        }\n\n        private function onAsyncLoadComplete(event:Event):void{\n            trace("Async. Image Load Complete");\n        }\n\n        private function loadImageSync():void{\n            trace("Loading image synchronously...");\n            urlRequest = new URLRequest("https://www.adobe.com/myimage.png");\n            urlRequest.useCache = false;\n            loader.load(urlRequest, loaderContext);\n            loader.contentLoaderInfo.addEventListener\n                (Event.COMPLETE, onSyncLoadComplete);\n        }\n\n        private function onSyncLoadComplete(event:Event):void{\n            trace("Sync. Image Load Complete");\n        }\n    }\n}\n')),(0,a.kt)("p",null,"For a demonstration of the effect of the different decoding policies, see\n",(0,a.kt)("a",{parentName:"p",href:"https://web.archive.org/web/20110526232051/http://www.bytearray.org/?p=2931"},"Thibault Imbert: Asynchronous bitmap decoding in the Adobe Flash runtimes")))}m.isMDXComponent=!0}}]);