"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[54864],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>v});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=a,v=p["".concat(l,".").concat(h)]||p[h]||u[h]||o;return n?i.createElement(v,r(r({ref:t},c),{},{components:n})):i.createElement(v,r({ref:t},c))}));function v(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},33666:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));const o={sidebar_position:2},r="Adding virtual keyboard support for interactive objects",s={unversionedId:"development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects",id:"development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects",title:"Adding virtual keyboard support for interactive objects",description:"Normally, the virtual keyboard only opens when a TextField object is tapped. You",source:"@site/docs/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects.md",sourceDirName:"development/user-interaction/keyboard-input/virtual-keyboards",slug:"/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects",permalink:"/docs/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects",draft:!1,editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/user-interaction/keyboard-input/virtual-keyboards/adding-virtual-keyboard-support-for-interactive-objects.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"mainSidebar",previous:{title:"Controlling virtual keyboard behavior",permalink:"/docs/development/user-interaction/keyboard-input/virtual-keyboards/controlling-virtual-keyboard-behavior"},next:{title:"Handling application display changes",permalink:"/docs/development/user-interaction/keyboard-input/virtual-keyboards/handling-application-display-changes"}},l={},d=[],c={toc:d},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adding-virtual-keyboard-support-for-interactive-objects"},"Adding virtual keyboard support for interactive objects"),(0,a.kt)("p",null,"Normally, the virtual keyboard only opens when a TextField object is tapped. You\ncan configure an instance of the InteractiveObject class to open the virtual\nkeyboard when it receives focus."),(0,a.kt)("p",null,"To configure an InteractiveObject instance to open the soft keyboard, set its\n",(0,a.kt)("inlineCode",{parentName:"p"},"needsSoftKeyboard")," property to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". Whenever the object is assigned to the\nstage focus property, the soft keyboard automatically opens. In addition, you\ncan raise the keyboard by calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"requestSoftKeyboard()")," method of the\nInteractiveObject."),(0,a.kt)("p",null,"The following example illustrates how you can program an InteractiveObject to\nact as a text entry field. The TextInput class shown in the example sets the\n",(0,a.kt)("inlineCode",{parentName:"p"},"needsSoftKeyboard")," property so that the keyboard is raised when needed. The\nobject then listens for ",(0,a.kt)("inlineCode",{parentName:"p"},"keyDown")," events and inserts the typed character into\nthe field."),(0,a.kt)("p",null,"The example uses the Flash text engine to append and display any typed text and\nhandles some important events. For simplicity, the example does not implement a\nfull-featured text field."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'package  {\n    import flash.geom.Rectangle;\n    import flash.display.Sprite;\n    import flash.text.engine.TextElement;\n    import flash.text.engine.TextBlock;\n    import flash.events.MouseEvent;\n    import flash.events.FocusEvent;\n    import flash.events.KeyboardEvent;\n    import flash.text.engine.TextLine;\n    import flash.text.engine.ElementFormat;\n    import flash.events.Event;\n\n    public class TextInput extends Sprite\n    {\n\n        public var text:String = " ";\n        public  var textSize:Number = 24;\n        public var textColor:uint = 0x000000;\n        private var _bounds:Rectangle = new Rectangle( 0, 0, 100, textSize );\n        private var textElement: TextElement;\n        private var textBlock:TextBlock = new  TextBlock();\n\n        public function TextInput( text:String = "" )\n        {\n            this.text = text;\n            this.scrollRect = _bounds;\n            this.focusRect= false;\n\n            //Enable keyboard support\n            this.needsSoftKeyboard = true;\n            this.addEventListener(MouseEvent.MOUSE_DOWN, onSelect);\n            this.addEventListener(FocusEvent.FOCUS_IN, onFocusIn);\n            this.addEventListener(FocusEvent.FOCUS_OUT, onFocusOut);\n\n            //Setup text engine\n            textElement = new TextElement( text, new ElementFormat( null, textSize, textColor ) );\n            textBlock.content = textElement;\n            var firstLine:TextLine = textBlock.createTextLine( null, _bounds.width - 8 );\n            firstLine.x = 4;\n            firstLine.y = 4 + firstLine.totalHeight;\n            this.addChild( firstLine );\n\n        }\n\n        private function onSelect( event:MouseEvent ):void\n        {\n            stage.focus = this;\n        }\n        private function onFocusIn( event:FocusEvent ):void\n        {\n            this.addEventListener( KeyboardEvent.KEY_DOWN, onKey );\n        }\n\n        private function onFocusOut( event:FocusEvent ):void\n        {\n            this.removeEventListener( KeyboardEvent.KEY_UP, onKey );\n        }\n\n        private function onKey( event:KeyboardEvent ):void\n        {\n            textElement.replaceText( textElement.text.length, textElement.text.length, String.fromCharCode( event.charCode ) );\n            updateText();\n        }\n        public function set bounds( newBounds:Rectangle ):void\n        {\n            _bounds = newBounds.clone();\n            drawBackground();\n            updateText();\n            this.scrollRect = _bounds;\n\n            //force update to focus rect, if needed\n            if( this.stage!= null && this.focusRect && this.stage.focus == this )\n                this.stage.focus = this;\n        }\n\n        private function updateText():void\n        {\n            //clear text lines\n            while( this.numChildren > 0 ) this.removeChildAt( 0 );\n\n            //and recreate them\n            var textLine:TextLine = textBlock.createTextLine( null, _bounds.width - 8);\n            while ( textLine)\n            {\n                textLine.x = 4;\n                if( textLine.previousLine != null )\n                {\n                    textLine.y = textLine.previousLine.y +\n                                textLine.previousLine.totalHeight + 2;\n                }\n                                else\n                {\n                    textLine.y = 4 + textLine.totalHeight;\n                }\n                this.addChild(textLine);\n                textLine = textBlock.createTextLine(textLine, _bounds.width - 8 );\n                }\n        }\n\n        private function drawBackground():void\n        {\n            //draw background and border for the field\n            this.graphics.clear();\n            this.graphics.beginFill( 0xededed );\n            this.graphics.lineStyle( 1, 0x000000 );\n            this.graphics.drawRect( _bounds.x + 2, _bounds.y + 2, _bounds.width - 4, _bounds.height - 4);\n            this.graphics.endFill();\n        }\n    }\n}\n')),(0,a.kt)("p",null,"The following main application class illustrates how to use the TextInput class\nand manage the application layout when the keyboard is raised or the device\norientation changes. The main class creates a TextInput object and sets its\nbounds to fill the stage. The class adjusts the size of the TextInput object\nwhen either the soft keyboard is raised or the stage changes size. The class\nlistens for soft keyboard events from the TextInput object and resize events\nfrom the stage. Irrespective of the cause of the event, the application\ndetermines the visible area of the stage and resizes the input control to fill\nit. Naturally, in a real application, you would need a more sophisticated layout\nalgorithm."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'package  {\n\n    import flash.display.MovieClip;\n    import flash.events.SoftKeyboardEvent;\n    import flash.geom.Rectangle;\n    import flash.events.Event;\n    import flash.display.StageScaleMode;\n    import flash.display.StageAlign;\n\n    public class CustomTextField extends MovieClip {\n\n        private var customField:TextInput = new TextInput("Input text: ");\n\n        public function CustomTextField() {\n            this.stage.scaleMode = StageScaleMode.NO_SCALE;\n            this.stage.align = StageAlign.TOP_LEFT;\n            this.addChild( customField );\n            customField.bounds = new Rectangle( 0, 0, this.stage.stageWidth, this.stage.stageHeight );\n\n            //track soft keyboard and stage resize events\n            customField.addEventListener(SoftKeyboardEvent.SOFT_KEYBOARD_ACTIVATE, onDisplayAreaChange );\n            customField.addEventListener(SoftKeyboardEvent.SOFT_KEYBOARD_DEACTIVATE, onDisplayAreaChange );\n            this.stage.addEventListener( Event.RESIZE, onDisplayAreaChange );\n        }\n\n        private function onDisplayAreaChange( event:Event ):void\n        {\n            //Fill the stage if possible, but avoid the area covered by a keyboard\n            var desiredBounds = new Rectangle( 0, 0, this.stage.stageWidth, this.stage.stageHeight );\n            if( this.stage.stageHeight - this.stage.softKeyboardRect.height < desiredBounds.height )\n                desiredBounds.height = this.stage.stageHeight - this.stage.softKeyboardRect.height;\n\n            customField.bounds = desiredBounds;\n        }\n    }\n}\n')),(0,a.kt)("p",null,"Note: The stage only dispatches resize events in response to an orientation\nchange when the ",(0,a.kt)("inlineCode",{parentName:"p"},"scaleMode")," property is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"noScale"),". In other modes, the\ndimensions of the stage do not change; instead, the content is scaled to\ncompensate."))}u.isMDXComponent=!0}}]);