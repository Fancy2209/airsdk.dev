"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[69162],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=a.createContext({}),s=function(e){var n=a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(d.Provider,{value:n},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=s(t),u=r,m=h["".concat(d,".").concat(u)]||h[u]||c[u]||i;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l[h]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5530:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=t(87462),r=(t(67294),t(3905));const i={},o="Using a shader as a drawing fill",l={unversionedId:"development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill",id:"development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill",title:"Using a shader as a drawing fill",description:"When you use a shader to create a drawing fill, you use the drawing api methods",source:"@site/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill.md",sourceDirName:"development/display/working-with-pixel-bender-shaders",slug:"/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill",permalink:"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill",draft:!1,editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-drawing-fill.md",tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Using a shader as a blend mode",permalink:"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-blend-mode"},next:{title:"Using a shader as a filter",permalink:"/docs/development/display/working-with-pixel-bender-shaders/using-a-shader-as-a-filter"}},d={},s=[],p={toc:s},h="wrapper";function c(e){let{components:n,...i}=e;return(0,r.kt)(h,(0,a.Z)({},p,i,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-a-shader-as-a-drawing-fill"},"Using a shader as a drawing fill"),(0,r.kt)("p",null,"When you use a shader to create a drawing fill, you use the drawing api methods\nto create a vector shape. The shader's output is used to fill in the shape, in\nthe same way that any bitmap image can be used as a bitmap fill with the drawing\napi. To create a shader fill, at the point in your code at which you want to\nstart drawing the shape, call the Graphics object's ",(0,r.kt)("inlineCode",{parentName:"p"},"beginShaderFill()")," method.\nPass the Shader object as the first argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"beginShaderFill()")," method,\nas shown in this listing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"var canvas:Sprite = new Sprite();\ncanvas.graphics.beginShaderFill(myShader);\ncanvas.graphics.drawRect(10, 10, 150, 150);\ncanvas.graphics.endFill();\n// add canvas to the display list to see the result\n")),(0,r.kt)("p",null,"When you use a shader as a drawing fill, you set any input image values and\nparameter values that the shader requires."),(0,r.kt)("p",null,"The following example demonstrates using a shader as a drawing fill. In this\nexample, the shader creates a three-point gradient. This gradient has three\ncolors, each at the point of a triangle, with a gradient blend between them. In\naddition, the colors rotate to create an animated spinning color effect."),(0,r.kt)("p",null,(0,r.kt)("img",{src:t(35860).Z,width:"280",height:"281"})),(0,r.kt)("p",null,"Note: The code for this example was written by Petri Leskinen. Thank you Petri\nfor sharing this example. You can see more of Petri's examples and tutorials at\n",(0,r.kt)("a",{parentName:"p",href:"http://pixelero.wordpress.com/"},"http://pixelero.wordpress.com/"),"."),(0,r.kt)("p",null,"The ActionScript code is in three methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"init()"),": The ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," method is called when the application loads. In this\nmethod the code sets the initial values for the Point objects representing the\npoints of the triangle. The also code creates a Sprite instance named\n",(0,r.kt)("inlineCode",{parentName:"p"},"canvas"),". Later, in the ",(0,r.kt)("inlineCode",{parentName:"p"},"updateShaderFill()"),", the code draws the shader result\ninto ",(0,r.kt)("inlineCode",{parentName:"p"},"canvas")," once per frame. Finally, the code loads the shader bytecode\nfile.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"onLoadComplete()"),": In the ",(0,r.kt)("inlineCode",{parentName:"p"},"onLoadComplete()")," method the code creates the\nShader object named ",(0,r.kt)("inlineCode",{parentName:"p"},"shader"),". It also sets the initial parameter values.\nFinally, the code adds the ",(0,r.kt)("inlineCode",{parentName:"p"},"updateShaderFill()")," method as a listener for the\n",(0,r.kt)("inlineCode",{parentName:"p"},"enterFrame")," event, meaning that it is called once per frame to create an\nanimation effect.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"updateShaderFill()"),": The ",(0,r.kt)("inlineCode",{parentName:"p"},"updateShaderFill()")," method is called once per\nframe, creating the animation effect. In this method, the code calculates and\nsets the shader parameters' values. The code then calls the\n",(0,r.kt)("inlineCode",{parentName:"p"},"beginShaderFill()")," method to create a shader fill and calls other drawing api\nmethods to draw the shader result in a triangle."))),(0,r.kt)("p",null,"The following is the ActionScript code for this example. Use this class as the\nmain application class for an ActionScript-only project in Flash Builder, or as\nthe document class for a FLA file in Flash Professional:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'package\n{\n    import flash.display.Shader;\n    import flash.display.Sprite;\n    import flash.events.Event;\n    import flash.geom.Point;\n    import flash.net.URLLoader;\n    import flash.net.URLLoaderDataFormat;\n    import flash.net.URLRequest;\n\n    public class ThreePointGradient extends Sprite\n    {\n        private var canvas:Sprite;\n        private var shader:Shader;\n        private var loader:URLLoader;\n\n        private var topMiddle:Point;\n        private var bottomLeft:Point;\n        private var bottomRight:Point;\n\n        private var colorAngle:Number = 0.0;\n        private const d120:Number = 120 / 180 * Math.PI; // 120 degrees in radians\n\n\n        public function ThreePointGradient()\n        {\n            init();\n        }\n\n        private function init():void\n        {\n            canvas = new Sprite();\n            addChild(canvas);\n\n            var size:int = 400;\n            topMiddle = new Point(size / 2, 10);\n            bottomLeft = new Point(0, size - 10);\n            bottomRight = new Point(size, size - 10);\n\n            loader = new URLLoader();\n            loader.dataFormat = URLLoaderDataFormat.BINARY;\n            loader.addEventListener(Event.COMPLETE, onLoadComplete);\n            loader.load(new URLRequest("ThreePointGradient.pbj"));\n        }\n\n        private function onLoadComplete(event:Event):void\n        {\n            shader = new Shader(loader.data);\n\n            shader.data.point1.value = [topMiddle.x, topMiddle.y];\n            shader.data.point2.value = [bottomLeft.x, bottomLeft.y];\n            shader.data.point3.value = [bottomRight.x, bottomRight.y];\n\n            addEventListener(Event.ENTER_FRAME, updateShaderFill);\n        }\n\n        private function updateShaderFill(event:Event):void\n        {\n            colorAngle += .06;\n\n            var c1:Number = 1 / 3 + 2 / 3 * Math.cos(colorAngle);\n            var c2:Number = 1 / 3 + 2 / 3 * Math.cos(colorAngle + d120);\n            var c3:Number = 1 / 3 + 2 / 3 * Math.cos(colorAngle - d120);\n\n            shader.data.color1.value = [c1, c2, c3, 1.0];\n            shader.data.color2.value = [c3, c1, c2, 1.0];\n            shader.data.color3.value = [c2, c3, c1, 1.0];\n\n            canvas.graphics.clear();\n            canvas.graphics.beginShaderFill(shader);\n\n            canvas.graphics.moveTo(topMiddle.x, topMiddle.y);\n            canvas.graphics.lineTo(bottomLeft.x, bottomLeft.y);\n            canvas.graphics.lineTo(bottomRight.x, bottomLeft.y);\n\n            canvas.graphics.endFill();\n        }\n    }\n}\n')),(0,r.kt)("p",null,'The following is the source code for the ThreePointGradient shader kernel, used\nto create the "ThreePointGradient.pbj" Pixel Bender bytecode file:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'<languageVersion : 1.0;>\nkernel ThreePointGradient\n<\nnamespace : "Petri Leskinen::Example";\nvendor : "Petri Leskinen";\nversion : 1;\ndescription : "Creates a gradient fill using three specified points and colors.";\n>\n{\n    parameter float2 point1 // coordinates of the first point\n    <\n        minValue:float2(0, 0);\n        maxValue:float2(4000, 4000);\n        defaultValue:float2(0, 0);\n    >;\n\n    parameter float4 color1 // color at the first point, opaque red by default\n    <\n        defaultValue:float4(1.0, 0.0, 0.0, 1.0);\n    >;\n\n    parameter float2 point2 // coordinates of the second point\n    <\n        minValue:float2(0, 0);\n        maxValue:float2(4000, 4000);\n        defaultValue:float2(0, 500);\n    >;\n\n    parameter float4 color2 // color at the second point, opaque green by default\n    <\n        defaultValue:float4(0.0, 1.0, 0.0, 1.0);\n    >;\n\n    parameter float2 point3 // coordinates of the third point\n    <\n        minValue:float2(0, 0);\n        maxValue:float2(4000, 4000);\n        defaultValue:float2(0, 500);\n    >;\n\n    parameter float4 color3 // color at the third point, opaque blue by default\n    <\n        defaultValue:float4(0.0, 0.0, 1.0, 1.0);\n    >;\n\n    output pixel4 dst;\n\n    void evaluatePixel()\n    {\n        float2 d2 = point2 - point1;\n        float2 d3 = point3 - point1;\n\n        // transformation to a new coordinate system\n        // transforms point 1 to origin, point2 to (1, 0), and point3 to (0, 1)\n        float2x2 mtrx = float2x2(d3.y, -d2.y, -d3.x, d2.x) / (d2.x * d3.y - d3.x * d2.y);\n        float2 pNew = mtrx * (outCoord() - point1);\n\n        // repeat the edge colors on the outside\n        pNew.xy = clamp(pNew.xy, 0.0, 1.0); // set the range to 0.0 ... 1.0\n\n        // interpolating the output color or alpha value\n        dst = mix(mix(color1, color2, pNew.x), color3, pNew.y);\n    }\n}\n')),(0,r.kt)("p",null,"Note: If you use a shader fill when rendering under the graphics processing unit\n(GPU), the filled area will be colored cyan."),(0,r.kt)("p",null,"For more information about drawing shapes using the drawing api, see\n",(0,r.kt)("a",{parentName:"p",href:"/docs/development/display/using-the-drawing-api/"},"Using the drawing API"),"."))}c.isMDXComponent=!0},35860:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/sb_drawing_fill_three_point_gradient-977c160d20354e15add2bc99e8c4a0c9.png"}}]);