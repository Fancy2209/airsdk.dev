"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[60722],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=u(n),h=r,c=m["".concat(l,".").concat(h)]||m[h]||p[h]||i;return n?a.createElement(c,o(o({ref:t},d),{},{components:n})):a.createElement(c,o({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},77247:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const i={sidebar_position:1},o="Supported SQL syntax",s={unversionedId:"development/appendixes/sql-support-in-local-databases/supported-sql-syntax",id:"development/appendixes/sql-support-in-local-databases/supported-sql-syntax",title:"Supported SQL syntax",description:"The following SQL syntax listings are supported by the Adobe AIR SQL database",source:"@site/docs/development/appendixes/sql-support-in-local-databases/supported-sql-syntax.md",sourceDirName:"development/appendixes/sql-support-in-local-databases",slug:"/development/appendixes/sql-support-in-local-databases/supported-sql-syntax",permalink:"/docs/development/appendixes/sql-support-in-local-databases/supported-sql-syntax",draft:!1,editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/appendixes/sql-support-in-local-databases/supported-sql-syntax.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"mainSidebar",previous:{title:"SQL support in local databases",permalink:"/docs/development/appendixes/sql-support-in-local-databases/"},next:{title:"Data type support",permalink:"/docs/development/appendixes/sql-support-in-local-databases/data-type-support"}},l={},u=[{value:"General SQL syntax",id:"general-sql-syntax",level:2},{value:"Data manipulation statements",id:"data-manipulation-statements",level:2},{value:"INSERT",id:"insert",level:4},{value:"UPDATE",id:"update",level:4},{value:"DELETE",id:"delete",level:4},{value:"Data definition statements",id:"data-definition-statements",level:2},{value:"CREATE TABLE",id:"create-table",level:4},{value:"ALTER TABLE",id:"alter-table",level:4},{value:"DROP TABLE",id:"drop-table",level:4},{value:"CREATE INDEX",id:"create-index",level:4},{value:"DROP INDEX",id:"drop-index",level:4},{value:"CREATE VIEW",id:"create-view",level:4},{value:"DROP VIEW",id:"drop-view",level:4},{value:"CREATE TRIGGER",id:"create-trigger",level:4},{value:"RAISE () function",id:"raise--function",level:4},{value:"DROP TRIGGER",id:"drop-trigger",level:4},{value:"Special statements and clauses",id:"special-statements-and-clauses",level:2},{value:"COLLATE",id:"collate",level:4},{value:"EXPLAIN",id:"explain",level:4},{value:"ON CONFLICT (conflict algorithms)",id:"on-conflict-conflict-algorithms",level:4},{value:"REINDEX",id:"reindex",level:4},{value:"COMMENTS",id:"comments",level:4},{value:"EXPRESSIONS",id:"expressions",level:4},{value:"Literal values",id:"literal-values",level:4},{value:"Column name",id:"column-name",level:4},{value:"SELECT statement",id:"select-statement",level:4},{value:"CAST expression",id:"cast-expression",level:4},{value:"Additional expression elements",id:"additional-expression-elements",level:4},{value:"Built-in functions",id:"built-in-functions",level:2},{value:"Aggregate functions",id:"aggregate-functions",level:4},{value:"Scalar functions",id:"scalar-functions",level:4},{value:"Date and time formatting functions",id:"date-and-time-formatting-functions",level:4},{value:"Time formats",id:"time-formats",level:4},{value:"Modifiers",id:"modifiers",level:4},{value:"Operators",id:"operators",level:2},{value:"Common operators",id:"common-operators",level:4},{value:"SQL operators",id:"sql-operators",level:4},{value:"Parameters",id:"parameters",level:2},{value:"Unsupported SQL features",id:"unsupported-sql-features",level:2},{value:"Additional SQL features",id:"additional-sql-features",level:2}],d={toc:u},m="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"supported-sql-syntax"},"Supported SQL syntax"),(0,r.kt)("p",null,"The following SQL syntax listings are supported by the Adobe AIR SQL database\nengine. The listings are divided into explanations of different statement and\nclause types, expressions, built-in functions, and operators. The following\ntopics are covered:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"General SQL syntax")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Data manipulation statements (SELECT, INSERT, UPDATE, and DELETE)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Data definition statements (CREATE, ALTER, and DROP statements for tables,\nindices, views, and triggers)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Special statements and clauses")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Built-in functions (Aggregate, scalar, and date/time formatting functions)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Operators")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Parameters")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Unsupported SQL features")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Additional SQL features"))),(0,r.kt)("h2",{id:"general-sql-syntax"},"General SQL syntax"),(0,r.kt)("p",null,"In addition to the specific syntax for various statements and expressions, the\nfollowing are general rules of SQL syntax:"),(0,r.kt)("p",null,"Case sensitivity",(0,r.kt)("br",{parentName:"p"}),"\n","SQL statements, including object names, are not case sensitive. Nevertheless,\nSQL statements are frequently written with SQL keywords written in uppercase,\nand this document uses that convention. While SQL syntax is not case sensitive,\nliteral text values in SQL are case sensitive, and comparison and sorting\noperations can be case sensitive, as specified by the collation sequence defined\nfor a column or operation. For more information see COLLATE."),(0,r.kt)("p",null,"White space",(0,r.kt)("br",{parentName:"p"}),"\n","A white-space character (such as space, tab, new line, and so forth) must be\nused to separate individual words in an SQL statement. However, white space is\noptional between words and symbols. The type and quantity of white-space\ncharacters in a SQL statement is not significant. You can use white space, such\nas indenting and line breaks, to format your SQL statements for easy\nreadability, without affecting the meaning of the statement."),(0,r.kt)("h2",{id:"data-manipulation-statements"},"Data manipulation statements"),(0,r.kt)("p",null,"Data manipulation statements are the most commonly used SQL statements. These\nstatements are used to retrieve, add, modify, and remove data from database\ntables. The following data manipulation statements are supported: SELECT,\nINSERT, UPDATE, and DELETE."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"SELECT")),(0,r.kt)("p",null,"The SELECT statement is used to query the database. The result of a SELECT is\nzero or more rows of data where each row has a fixed number of columns. The\nnumber of columns in the result is specified by the result column name or\nexpression list between the SELECT and optional FROM keywords."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement   ::=  SELECT [ALL | DISTINCT] result\n                 [FROM table-list]\n                 [WHERE expr]\n                 [GROUP BY expr-list]\n                 [HAVING expr]\n                 [compound-op select-statement]*\n                 [ORDER BY sort-expr-list]\n                 [LIMIT integer [( OFFSET | , ) integer]]\nresult          ::=  result-column [, result-column]*\nresult-column   ::=  * | table-name . * | expr [[AS] string]\ntable-list      ::=  table [ join-op table join-args ]*\ntable           ::=  table-name [AS alias] |\n                 ( select ) [AS alias]\njoin-op         ::=  , | [NATURAL] [LEFT | RIGHT | FULL] [OUTER | INNER | CROSS] JOIN\njoin-args       ::=  [ON expr] [USING ( id-list )]\ncompound-op     ::=  UNION | UNION ALL | INTERSECT | EXCEPT\nsort-expr-list  ::=  expr [sort-order] [, expr [sort-order]]*\nsort-order      ::=  [COLLATE collation-name] [ASC | DESC]\ncollation-name  ::=  BINARY | NOCASE\n")),(0,r.kt)("p",null,"Any arbitrary expression can be used as a result. If a result expression is ","*","\nthen all columns of all tables are substituted for that one expression. If the\nexpression is the name of a table followed by .","*"," then the result is all columns\nin that one table."),(0,r.kt)("p",null,"The DISTINCT keyword causes a subset of result rows to be returned, in which\neach result row is different. NULL values are not treated as distinct from each\nother. The default behavior is that all result rows are returned, which can be\nmade explicit with the keyword ALL."),(0,r.kt)("p",null,"The query is executed against one or more tables specified after the FROM\nkeyword. If multiple table names are separated by commas, then the query uses\nthe cross join of the various tables. The JOIN syntax can also be used to\nspecify how tables are joined. The only type of outer join that is supported is\nLEFT OUTER JOIN. The ON clause expression in join-args must resolve to a boolean\nvalue. A subquery in parentheses may be used as a table in the FROM clause. The\nentire FROM clause may be omitted, in which case the result is a single row\nconsisting of the values of the result expression list."),(0,r.kt)("p",null,"The WHERE clause is used to limit the number of rows the query retrieves. WHERE\nclause expressions must resolve to a boolean value. WHERE clause filtering is\nperformed before any grouping, so WHERE clause expressions may not include\naggregate functions."),(0,r.kt)("p",null,"The GROUP BY clause causes one or more rows of the result to be combined into a\nsingle row of output. A GROUP BY clause is especially useful when the result\ncontains aggregate functions. The expressions in the GROUP BY clause do not have\nto be expressions that appear in the SELECT expression list."),(0,r.kt)("p",null,"The HAVING clause is like WHERE in that it limits the rows returned by the\nstatement. However, the HAVING clause applies after any grouping specified by a\nGROUP BY clause has occurred. Consequently, the HAVING expression may refer to\nvalues that include aggregate functions. A HAVING clause expression is not\nrequired to appear in the SELECT list. Like a WHERE expression, a HAVING\nexpression must resolve to a boolean value."),(0,r.kt)("p",null,"The ORDER BY clause causes the output rows to be sorted. The sort-expr-list\nargument to the ORDER BY clause is a list of expressions that are used as the\nkey for the sort. The expressions do not have to be part of the result for a\nsimple SELECT, but in a compound SELECT (a SELECT using one of the compound-op\noperators) each sort expression must exactly match one of the result columns.\nEach sort expression may be optionally followed by a sort-order clause\nconsisting of the COLLATE keyword and the name of a collation function used for\nordering text and/or the keyword ASC or DESC to specify the sort order\n(ascending or descending). The sort-order can be omitted and the default\n(ascending order) is used. For a definition of the COLLATE clause and collation\nfunctions, see COLLATE."),(0,r.kt)("p",null,"The LIMIT clause places an upper bound on the number of rows returned in the\nresult. A negative LIMIT indicates no upper bound. The optional OFFSET following\nLIMIT specifies how many rows to skip at the beginning of the result set. In a\ncompound SELECT query, the LIMIT clause may only appear after the final SELECT\nstatement, and the limit is applied to the entire query. Note that if the OFFSET\nkeyword is used in the LIMIT clause, then the limit is the first integer and the\noffset is the second integer. If a comma is used instead of the OFFSET keyword,\nthen the offset is the first number and the limit is the second number. This\nseeming contradiction is intentional \u2014 it maximizes compatibility with legacy\nSQL database systems."),(0,r.kt)("p",null,"A compound SELECT is formed from two or more simple SELECT statements connected\nby one of the operators UNION, UNION ALL, INTERSECT, or EXCEPT. In a compound\nSELECT, all the constituent SELECT statements must specify the same number of\nresult columns. There can only be a single ORDER BY clause after the final\nSELECT statement (and before the single LIMIT clause, if one is specified). The\nUNION and UNION ALL operators combine the results of the preceding and following\nSELECT statements into a single table. The difference is that in UNION, all\nresult rows are distinct, but in UNION ALL, there may be duplicates. The\nINTERSECT operator takes the intersection of the results of the preceding and\nfollowing SELECT statements. EXCEPT takes the result of preceding SELECT after\nremoving the results of the following SELECT. When three or more SELECT\nstatements are connected into a compound, they group from first to last."),(0,r.kt)("p",null,"For a definition of permitted expressions, see Expressions."),(0,r.kt)("p",null,"Starting with AIR 2.5, the SQL CAST operator is supported when reading to\nconvert BLOB data to ActionScript ByteArray objects. For example, the following\ncode reads raw data that is not stored in the AMF format and stores it in a\nByteArray object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'stmt.text = "SELECT CAST(data AS ByteArray) AS data FROM pictures;";\nstmt.execute();\nvar result:SQLResult = stmt.getResult();\nvar bytes:ByteArray = result.data[0].data;\n')),(0,r.kt)("h4",{id:"insert"},"INSERT"),(0,r.kt)("p",null,"The INSERT statement comes in two basic forms and is used to populate tables\nwith data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  INSERT [OR conflict-algorithm] INTO [database-name.] table-name [(column-list)] VALUES (value-list) |\n                INSERT [OR conflict-algorithm] INTO [database-name.] table-name [(column-list)] select-statement\n                REPLACE INTO [database-name.] table-name [(column-list)] VALUES (value-list) |\n                REPLACE INTO [database-name.] table-name [(column-list)] select-statement\n")),(0,r.kt)("p",null,"The first form (with the VALUES keyword) creates a single new row in an existing\ntable. If no column-list is specified then the number of values must be the same\nas the number of columns in the table. If a column-list is specified, then the\nnumber of values must match the number of specified columns. Columns of the\ntable that do not appear in the column list are filled with the default value\ndefined when the table is created, or with NULL if no default value is defined."),(0,r.kt)("p",null,"The second form of the INSERT statement takes its data from a SELECT statement.\nThe number of columns in the result of the SELECT must exactly match the number\nof columns in the table if column-list is not specified, or it must match the\nnumber of columns named in the column-list. A new entry is made in the table for\nevery row of the SELECT result. The SELECT may be simple or compound. For a\ndefinition of allowable SELECT statements, see SELECT."),(0,r.kt)("p",null,"The optional conflict-algorithm allows the specification of an alternative\nconstraint conflict resolution algorithm to use during this one command. For an\nexplanation and definition of conflict algorithms, see\n",(0,r.kt)("a",{parentName:"p",href:"#special-statements-and-clauses"},"Special statements and clauses"),"."),(0,r.kt)("p",null,"The two REPLACE INTO forms of the statement are equivalent to using the standard\nINSERT ","[","OR conflict-algorithm","]"," form with the REPLACE conflict algorithm (i.e.\nthe INSERT OR REPLACE... form)."),(0,r.kt)("p",null,"The two REPLACE INTO forms of the statement are equivalent to using the standard\nINSERT ","[","OR conflict-algorithm","]"," form with the REPLACE conflict algorithm (i.e.\nthe INSERT OR REPLACE... form)."),(0,r.kt)("h4",{id:"update"},"UPDATE"),(0,r.kt)("p",null,"The update command changes the existing records in a table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  UPDATE [database-name.] table-name SET column1=value1, column2=value2,... [WHERE expr]\n")),(0,r.kt)("p",null,"The command consists of the UPDATE keyword followed by the name of the table in\nwhich you want to update the records. After the SET keyword, provide the name of\nthe column and the value to which the column to be changed as a comma-separated\nlist. The WHERE clause expression provides the row or rows in which the records\nare updated."),(0,r.kt)("h4",{id:"delete"},"DELETE"),(0,r.kt)("p",null,"The delete command is used to remove records from a table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  DELETE FROM [database-name.] table-name [WHERE expr]\n")),(0,r.kt)("p",null,"The command consists of the DELETE FROM keywords followed by the name of the\ntable from which records are to be removed."),(0,r.kt)("p",null,"Without a WHERE clause, all rows of the table are removed. If a WHERE clause is\nsupplied, then only those rows that match the expression are removed. The WHERE\nclause expression must resolve to a boolean value. For a definition of permitted\nexpressions, see Expressions."),(0,r.kt)("h2",{id:"data-definition-statements"},"Data definition statements"),(0,r.kt)("p",null,"Data definition statements are used to create, modify, and remove database\nobjects such as tables, views, indices, and triggers. The following data\ndefinition statements are supported:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Tables:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"CREATE TABLE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ALTER TABLE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DROP TABLE")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Indices:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"CREATE INDEX")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DROP INDEX")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Views:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"CREATE VIEWS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DROP VIEWS")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Triggers:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"CREATE TRIGGERS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DROP TRIGGERS"))))),(0,r.kt)("h4",{id:"create-table"},"CREATE TABLE"),(0,r.kt)("p",null,"A CREATE TABLE statement consists of the keywords CREATE TABLE followed by the\nname of the new table, then (in parentheses) a list of column definitions and\nconstraints. The table name can be either an identifier or a string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement       ::=  CREATE [TEMP | TEMPORARY] TABLE [IF NOT EXISTS] [database-name.] table-name\n                     ( column-def [, column-def]* [, constraint]* )\nsql-statement       ::=  CREATE [TEMP | TEMPORARY] TABLE [database-name.] table-name AS select-statement\ncolumn-def          ::=  name [type] [[CONSTRAINT name] column-constraint]*\ntype                ::=  typename | typename ( number ) | typename ( number , number )\ncolumn-constraint   ::=  NOT NULL [ conflict-clause ] |\n                     PRIMARY KEY [sort-order] [ conflict-clause ] [AUTOINCREMENT] |\n                     UNIQUE [conflict-clause] |\n                     CHECK ( expr ) |\n                     DEFAULT default-value |\n                     COLLATE collation-name\nconstraint          ::=  PRIMARY KEY ( column-list ) [conflict-clause] |\n                     UNIQUE ( column-list ) [conflict-clause] |\n                     CHECK ( expr )\nconflict-clause     ::=  ON CONFLICT conflict-algorithm\nconflict-algorithm  ::=  ROLLBACK | ABORT | FAIL | IGNORE | REPLACE\ndefault-value       ::=  NULL | string | number | CURRENT_TIME | CURRENT_DATE | CURRENT_TIMESTAMP\nsort-order          ::=  ASC | DESC\ncollation-name      ::=  BINARY | NOCASE\ncolumn-list         ::=  column-name [, column-name]*\n")),(0,r.kt)("p",null,"Each column definition is the name of the column followed by the data type for\nthat column, then one or more optional column constraints. The data type for the\ncolumn restricts what data may be stored in that column. If an attempt is made\nto store a value in a column with a different data type, the runtime converts\nthe value to the appropriate type if possible, or raises an error. See the Data\ntype support section for additional information."),(0,r.kt)("p",null,"The NOT NULL column constraint indicates that the column cannot contain NULL\nvalues."),(0,r.kt)("p",null,"A UNIQUE constraint causes an index to be created on the specified column or\ncolumns. This index must contain unique keys\u2014no two rows may contain duplicate\nvalues or combinations of values for the specified column or columns. A CREATE\nTABLE statement can have multiple UNIQUE constraints, including multiple columns\nwith a UNIQUE constraint in the column's definition and/or multiple table-level\nUNIQUE constraints."),(0,r.kt)("p",null,"A CHECK constraint defines an expression that is evaluated and must be true in\norder for a row's data to be inserted or updated. The CHECK expression must\nresolve to a boolean value."),(0,r.kt)("p",null,"A COLLATE clause in a column definition specifies what text collation function\nto use when comparing text entries for the column. The BINARY collating function\nis used by default. For details on the COLLATE clause and collation functions,\nsee COLLATE."),(0,r.kt)("p",null,"The DEFAULT constraint specifies a default value to use when doing an INSERT.\nThe value may be NULL, a string constant, or a number. The default value may\nalso be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE\nor CURRENT_TIMESTAMP. If the value is NULL, a string constant, or a number, it\nis literally inserted into the column whenever an INSERT statement does not\nspecify a value for the column. If the value is CURRENT_TIME, CURRENT_DATE or\nCURRENT_TIMESTAMP, then the current UTC date and/or time is inserted into the\ncolumn. For CURRENT_TIME, the format is HH:MM:SS. For CURRENT_DATE, the format\nis YYYY-MM-DD. The format for CURRENT_TIMESTAMP is YYYY-MM-DD HH:MM:SS."),(0,r.kt)("p",null,"Specifying a PRIMARY KEY normally just creates a UNIQUE index on the\ncorresponding column or columns. However, if the PRIMARY KEY constraint is on a\nsingle column that has the data type INTEGER (or one of its synonyms such as\nint) then that column is used by the database as the actual primary key for the\ntable. This means that the column may only hold unique integer values. (Note\nthat in many SQLite implementations, only the column type INTEGER causes the\ncolumn to serve as the internal primary key, but in Adobe AIR synonyms for\nINTEGER such as int also specify that behavior.)"),(0,r.kt)("p",null,"If a table does not have an INTEGER PRIMARY KEY column, an integer key is\nautomatically generated when a row is inserted. The primary key for a row can\nalways be accessed using one of the special names ROWID, OID, or ","_","ROWID","_",".\nThese names can be used regardless of whether it is an explicitly declared\nINTEGER PRIMARY KEY or an internal generated value. However, if the table has an\nexplicit INTEGER PRIMARY KEY, the name of the column in the result data is the\nactual column name rather than the special name."),(0,r.kt)("p",null,"An INTEGER PRIMARY KEY column can also include the keyword AUTOINCREMENT. When\nthe AUTOINCREMENT keyword is used, the database automatically generates and\ninserts a sequentially incremented integer key in the INTEGER PRIMARY KEY column\nwhen it executes an INSERT statement that doesn't specify an explicit value for\nthe column."),(0,r.kt)("p",null,"There can only be one PRIMARY KEY constraint in a CREATE TABLE statement. It can\neither be part of one column's definition or one single table-level PRIMARY KEY\nconstraint. A primary key column is implicitly NOT NULL."),(0,r.kt)("p",null,"The optional conflict-clause following many constraints allows the specification\nof an alternative default constraint conflict resolution algorithm for that\nconstraint. The default is ABORT. Different constraints within the same table\nmay have different default conflict resolution algorithms. If an INSERT or\nUPDATE statement specifies a different conflict resolution algorithm, that\nalgorithm is used in place of the algorithm specified in the CREATE TABLE\nstatement. See the ON CONFLICT section of\n",(0,r.kt)("a",{parentName:"p",href:"#special-statements-and-clauses"},"Special statements and clauses")," for additional\ninformation."),(0,r.kt)("p",null,"Additional constraints, such as FOREIGN KEY constraints, do not result in an\nerror but the runtime ignores them."),(0,r.kt)("p",null,"If the TEMP or TEMPORARY keyword occurs between CREATE and TABLE then the table\nthat is created is only visible within the same database connection\n(SQLConnection instance). It is automatically deleted when the database\nconnection is closed. Any indices created on a temporary table are also\ntemporary. Temporary tables and indices are stored in a separate file distinct\nfrom the main database file."),(0,r.kt)("p",null,"If the optional database-name prefix is specified, then the table is created in\na named database (a database that was connected to the SQLConnection instance by\ncalling the attach() method with the specified database name). It is an error to\nspecify both a database-name prefix and the TEMP keyword, unless the\ndatabase-name prefix is temp. If no database name is specified, and the TEMP\nkeyword is not present, the table is created in the main database (the database\nthat was connected to the SQLConnection instance using the open() or\nopenAsync()method)."),(0,r.kt)("p",null,"There are no arbitrary limits on the number of columns or on the number of\nconstraints in a table. There is also no arbitrary limit on the amount of data\nin a row."),(0,r.kt)("p",null,"The CREATE TABLE AS form defines the table as the result set of a query. The\nnames of the table columns are the names of the columns in the result."),(0,r.kt)("p",null,"If the optional IF NOT EXISTS clause is present and another table with the same\nname already exists, then the database ignores the CREATE TABLE command."),(0,r.kt)("p",null,"A table can be removed using the DROP TABLE statement, and limited changes can\nbe made using the ALTER TABLE statement."),(0,r.kt)("h4",{id:"alter-table"},"ALTER TABLE"),(0,r.kt)("p",null,"The ALTER TABLE command allows the user to rename or add a new column to an\nexisting table. It is not possible to remove a column from a table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement ::= ALTER TABLE [database-name.] table-name alteration\nalteration    ::= RENAME TO new-table-name\nalteration    ::= ADD [COLUMN] column-def\n")),(0,r.kt)("p",null,"The RENAME TO syntax is used to rename the table identified by\n","[","database-name.","]"," table-name to new-table-name. This command cannot be used to\nmove a table between attached databases, only to rename a table within the same\ndatabase."),(0,r.kt)("p",null,"If the table being renamed has triggers or indices, then they remain attached to\nthe table after it has been renamed. However, if there are any view definitions\nor statements executed by triggers that refer to the table being renamed, they\nare not automatically modified to use the new table name. If a renamed table has\nassociated views or triggers, you must manually drop and recreate the triggers\nor view definitions using the new table name."),(0,r.kt)("p",null,"The ADD ","[","COLUMN","]"," syntax is used to add a new column to an existing table. The\nnew column is always appended to the end of the list of existing columns. The\ncolumn-def clause may take any of the forms permissible in a CREATE TABLE\nstatement, with the following restrictions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The column may not have a PRIMARY KEY or UNIQUE constraint.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The column may not have a default value of CURRENT_TIME, CURRENT_DATE or\nCURRENT_TIMESTAMP.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a NOT NULL constraint is specified, the column must have a default value\nother than NULL."))),(0,r.kt)("p",null,"The execution time of the ALTER TABLE statement is not affected by the amount of\ndata in the table."),(0,r.kt)("h4",{id:"drop-table"},"DROP TABLE"),(0,r.kt)("p",null,"The DROP TABLE statement removes a table added with a CREATE TABLE statement.\nThe table with the specified table-name is the table that's dropped. It is\ncompletely removed from the database and the disk file. The table cannot be\nrecovered. All indices associated with the table are also deleted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  DROP TABLE [IF EXISTS] [database-name.] table-name\n")),(0,r.kt)("p",null,"By default the DROP TABLE statement does not reduce the size of the database\nfile. Empty space in the database is retained and used in subsequent INSERT\noperations. To remove free space in the database use the SQLConnection.clean()\nmethod. If the autoClean parameter is set to true when the database is initially\ncreated, the space is freed automatically."),(0,r.kt)("p",null,"The optional IF EXISTS clause suppresses the error that would normally result if\nthe table does not exist."),(0,r.kt)("h4",{id:"create-index"},"CREATE INDEX"),(0,r.kt)("p",null,"The CREATE INDEX command consists of the keywords CREATE INDEX followed by the\nname of the new index, the keyword ON, the name of a previously created table\nthat is to be indexed, and a parenthesized list of names of columns in the table\nwhose values are used for the index key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  CREATE [UNIQUE] INDEX [IF NOT EXISTS] [database-name.] index-name\n                ON table-name ( column-name [, column-name]* )\ncolumn-name    ::=  name [COLLATE collation-name] [ASC | DESC]\n")),(0,r.kt)("p",null,"Each column name can be followed by ASC or DESC keywords to indicate sort order,\nbut the sort order designation is ignored by the runtime. Sorting is always done\nin ascending order."),(0,r.kt)("p",null,"The COLLATE clause following each column name defines a collating sequence used\nfor text values in that column. The default collation sequence is the collation\nsequence defined for that column in the CREATE TABLE statement. If no collation\nsequence is specified, the BINARY collation sequence is used. For a definition\nof the COLLATE clause and collation functions see COLLATE."),(0,r.kt)("p",null,"There are no arbitrary limits on the number of indices that can be attached to a\nsingle table. There are also no limits on the number of columns in an index."),(0,r.kt)("h4",{id:"drop-index"},"DROP INDEX"),(0,r.kt)("p",null,"The drop index statement removes an index added with the CREATE INDEX statement.\nThe specified index is completely removed from the database file. The only way\nto recover the index is to reenter the appropriate CREATE INDEX command."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement ::= DROP INDEX [IF EXISTS] [database-name.] index-name\n")),(0,r.kt)("p",null,"By default the DROP INDEX statement does not reduce the size of the database\nfile. Empty space in the database is retained and used in subsequent INSERT\noperations. To remove free space in the database use the SQLConnection.clean()\nmethod. If the autoClean parameter is set to true when the database is initially\ncreated, the space is freed automatically."),(0,r.kt)("h4",{id:"create-view"},"CREATE VIEW"),(0,r.kt)("p",null,"The CREATE VIEW command assigns a name to a pre-defined SELECT statement. This\nnew name can then be used in a FROM clause of another SELECT statement in place\nof a table name. Views are commonly used to simplify queries by combining a\ncomplex (and frequently used) set of data into a structure that can be used in\nother operations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement ::= CREATE [TEMP | TEMPORARY] VIEW [IF NOT EXISTS] [database-name.] view-name AS select-statement\n")),(0,r.kt)("p",null,"If the TEMP or TEMPORARY keyword occurs in between CREATE and VIEW then the view\nthat is created is only visible to the SQLConnection instance that opened the\ndatabase and is automatically deleted when the database is closed."),(0,r.kt)("p",null,"If a ","[","database-name","]"," is specified the view is created in the named database (a\ndatabase that was connected to the SQLConnection instance using the attach()\nmethod, with the specified name argument. It is an error to specify both a\n","[","database-name","]"," and the TEMP keyword unless the ","[","database-name","]"," is temp. If\nno database name is specified, and the TEMP keyword is not present, the view is\ncreated in the main database (the database that was connected to the\nSQLConnection instance using the open() or openAsync() method)."),(0,r.kt)("p",null,"Views are read only. A DELETE, INSERT, or UPDATE statement cannot be used on a\nview, unless at least one trigger of the associated type (INSTEAD OF DELETE,\nINSTEAD OF INSERT, INSTEAD OF UPDATE) is defined. For information on creating a\ntrigger for a view, see CREATE TRIGGER."),(0,r.kt)("p",null,"A view is removed from a database using the DROP VIEW statement."),(0,r.kt)("h4",{id:"drop-view"},"DROP VIEW"),(0,r.kt)("p",null,"The DROP VIEW statement removes a view created by a CREATE VIEW statement."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement ::= DROP VIEW [IF EXISTS] view-name\n")),(0,r.kt)("p",null,"The specified view-name is the name of the view to drop. It is removed from the\ndatabase, but no data in the underlying tables is modified."),(0,r.kt)("h4",{id:"create-trigger"},"CREATE TRIGGER"),(0,r.kt)("p",null,"The create trigger statement is used to add triggers to the database schema. A\ntrigger is a database operation (the trigger-action) that is automatically\nperformed when a specified database event (the database-event) occurs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement   ::=  CREATE [TEMP | TEMPORARY] TRIGGER [IF NOT EXISTS] [database-name.] trigger-name\n                 [BEFORE | AFTER] database-event\n                 ON table-name\n                 trigger-action\nsql-statement   ::=  CREATE [TEMP | TEMPORARY] TRIGGER [IF NOT EXISTS] [database-name.] trigger-name\n                 INSTEAD OF database-event\n                 ON view-name\n                 trigger-action\ndatabase-event  ::=  DELETE |\n                 INSERT |\n                 UPDATE |\n                 UPDATE OF column-list\ntrigger-action  ::=  [FOR EACH ROW] [WHEN expr]\n                 BEGIN\n                   trigger-step ;\n                   [ trigger-step ; ]*\n                 END\ntrigger-step    ::=  update-statement |\n                 insert-statement |\n                 delete-statement |\n                 select-statement\ncolumn-list     ::=  column-name [, column-name]*\n")),(0,r.kt)("p",null,"A trigger is specified to fire whenever a DELETE, INSERT, or UPDATE of a\nparticular database table occurs, or whenever an UPDATE of one or more specified\ncolumns of a table are updated. Triggers are permanent unless the TEMP or\nTEMPORARY keyword is used. In that case the trigger is removed when the\nSQLConnection instance's main database connection is closed. If no timing is\nspecified (BEFORE or AFTER) the trigger defaults to BEFORE."),(0,r.kt)("p",null,"Only FOR EACH ROW triggers are supported, so the FOR EACH ROW text is optional.\nWith a FOR EACH ROW trigger, the trigger-step statements are executed for each\ndatabase row being inserted, updated or deleted by the statement causing the\ntrigger to fire, if the WHEN clause expression evaluates to true."),(0,r.kt)("p",null,"If a WHEN clause is supplied, the SQL statements specified as trigger-steps are\nonly executed for rows for which the WHEN clause is true. If no WHEN clause is\nsupplied, the SQL statements are executed for all rows."),(0,r.kt)("p",null,"Within the body of a trigger, (the trigger-action clause) the pre-change and\npost-change values of the affected table are available using the special table\nnames OLD and NEW. The structure of the OLD and NEW tables matches the structure\nof the table on which the trigger is created. The OLD table contains any rows\nthat are modified or deleted by the triggering statement, in their state before\nthe triggering statement's operations. The NEW table contains any rows that are\nmodified or created by the triggering statement, in their state after the\ntriggering statement's operations. Both the WHEN clause and the trigger-step\nstatements can access values from the row being inserted, deleted or updated\nusing references of the form NEW.column-name and OLD.column-name, where\ncolumn-name is the name of a column from the table with which the trigger is\nassociated. The availability of the OLD and NEW table references depends on the\ntype of database-event the trigger handles:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"INSERT \u2013 NEW references are valid")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"UPDATE \u2013 NEW and OLD references are valid")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DELETE \u2013 OLD references are valid"))),(0,r.kt)("p",null,"The specified timing (BEFORE, AFTER, or INSTEAD OF) determines when the\ntrigger-step statements are executed relative to the insertion, modification or\nremoval of the associated row. An ON CONFLICT clause may be specified as part of\nan UPDATE or INSERT statement in a trigger-step. However, if an ON CONFLICT\nclause is specified as part of the statement causing the trigger to fire, then\nthat conflict handling policy is used instead."),(0,r.kt)("p",null,"In addition to table triggers, an INSTEAD OF trigger can be created on a view.\nIf one or more INSTEAD OF INSERT, INSTEAD OF DELETE, or INSTEAD OF UPDATE\ntriggers are defined on a view, it is not considered an error to execute the\nassociated type of statement (INSERT, DELETE, or UPDATE) on the view. In that\ncase, executing an INSERT, DELETE or UPDATE on the view causes the associated\ntriggers to fire. Because the trigger is an INSTEAD OF trigger, the tables\nunderlying the view are not modified by the statement that causes the trigger to\nfire. However, the triggers can be used to perform modifying operations on the\nunderlying tables."),(0,r.kt)("p",null,"There is an important issue to keep in mind when creating a trigger on a table\nwith an INTEGER PRIMARY KEY column. If a BEFORE trigger modifies the INTEGER\nPRIMARY KEY column of a row that is to be updated by the statement that causes\nthe trigger to fire, the update doesn't occur. A workaround is to create the\ntable with a PRIMARY KEY column instead of an INTEGER PRIMARY KEY column."),(0,r.kt)("p",null,"A trigger can be removed using the DROP TRIGGER statement. When a table or view\nis dropped, all triggers associated with that table or view are automatically\ndropped as well."),(0,r.kt)("h4",{id:"raise--function"},"RAISE () function"),(0,r.kt)("p",null,"A special SQL function RAISE() can be used in a trigger-step statement of a\ntrigger. This function has the following syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"raise-function  ::=  RAISE ( ABORT, error-message ) |\n                 RAISE ( FAIL, error-message ) |\n                 RAISE ( ROLLBACK, error-message ) |\n                 RAISE ( IGNORE )\n")),(0,r.kt)("p",null,"When one of the first three forms is called during trigger execution, the\nspecified ON CONFLICT processing action (ABORT, FAIL, or ROLLBACK) is performed\nand the current statement's execution ends. The ROLLBACK is considered a\nstatement execution failure, so the SQLStatement instance whose execute() method\nwas being carried out dispatches an error (SQLErrorEvent.ERROR) event. The\nSQLError object in the dispatched event object's error property has its details\nproperty set to the error-message specified in the RAISE() function."),(0,r.kt)("p",null,"When RAISE(IGNORE) is called, the remainder of the current trigger, the\nstatement that caused the trigger to execute, and any subsequent triggers that\nwould have been executed are abandoned. No database changes are rolled back. If\nthe statement that caused the trigger to execute is itself part of a trigger,\nthat trigger program resumes execution at the beginning of the next step. For\nmore information about the conflict resolution algorithms, see the section ON\nCONFLICT (conflict algorithms)."),(0,r.kt)("h4",{id:"drop-trigger"},"DROP TRIGGER"),(0,r.kt)("p",null,"The DROP TRIGGER statement removes a trigger created by the CREATE TRIGGER\nstatement."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  DROP TRIGGER [IF EXISTS] [database-name.] trigger-name\n")),(0,r.kt)("p",null,"The trigger is deleted from the database. Note that triggers are automatically\ndropped when their associated table is dropped."),(0,r.kt)("h2",{id:"special-statements-and-clauses"},"Special statements and clauses"),(0,r.kt)("p",null,"This section describes several clauses that are extensions to SQL provided by\nthe runtime, as well as two language elements that can be used in many\nstatements, comments and expressions."),(0,r.kt)("h4",{id:"collate"},"COLLATE"),(0,r.kt)("p",null,"The COLLATE clause is used in SELECT, CREATE TABLE, and CREATE INDEX statements\nto specify the comparison algorithm that is used when comparing or sorting\nvalues."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement   ::=  COLLATE collation-name\ncollation-name  ::=  BINARY | NOCASE\n")),(0,r.kt)("p",null,"The default collation type for columns is BINARY. When BINARY collation is used\nwith values of the TEXT storage class, binary collation is performed by\ncomparing the bytes in memory that represent the value regardless of the text\nencoding."),(0,r.kt)("p",null,"The NOCASE collation sequence is only applied for values of the TEXT storage\nclass. When used, the NOCASE collation performs a case-insensitive comparison."),(0,r.kt)("p",null,"No collation sequence is used for storage classes of type NULL, BLOB, INTEGER,\nor REAL."),(0,r.kt)("p",null,"To use a collation type other than BINARY with a column, a COLLATE clause must\nbe specified as part of the column definition in the CREATE TABLE statement.\nWhenever two TEXT values are compared, a collation sequence is used to determine\nthe results of the comparison according to the following rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For binary comparison operators, if either operand is a column, then the\ndefault collation type of the column determines the collation sequence that is\nused for the comparison. If both operands are columns, then the collation type\nfor the left operand determines the collation sequence used. If neither\noperand is a column, then the BINARY collation sequence is used.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The BETWEEN...AND operator is equivalent to using two expressions with the ",">","=\nand \\<= operators. For example, the expression x BETWEEN y AND z is equivalent\nto x ",">","= y AND x \\<= z. Consequently, the BETWEEN...AND operator follows the\npreceding rule to determine the collation sequence.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The IN operator behaves like the =operator for the purposes of determining the\ncollation sequence to use. For example, the collation sequence used for the\nexpressionx IN (y, z) is the default collation type of x if x is a column.\nOtherwise, BINARY collation is used.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An ORDER BY clause that is part of a SELECT statement may be explicitly\nassigned a collation sequence to be used for the sort operation. In that case\nthe explicit collation sequence is always used. Otherwise, if the expression\nsorted by an ORDER BYclause is a column, the default collation type of the\ncolumn is used to determine sort order. If the expression is not a column, the\nBINARY collation sequence is used."))),(0,r.kt)("h4",{id:"explain"},"EXPLAIN"),(0,r.kt)("p",null,"The EXPLAIN command modifier is a non-standard extension to SQL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  EXPLAIN sql-statement\n")),(0,r.kt)("p",null,"If the EXPLAIN keyword appears before any other SQL statement, then instead of\nactually executing the command, the result reports the sequence of virtual\nmachine instructions it would have used to execute the command, had the EXPLAIN\nkeyword not been present. The EXPLAIN feature is an advanced feature and allows\ndevelopers to change SQL statement text in an attempt to optimize performance or\ndebug a statement that doesn't appear to be working properly."),(0,r.kt)("h4",{id:"on-conflict-conflict-algorithms"},"ON CONFLICT (conflict algorithms)"),(0,r.kt)("p",null,"The ON CONFLICT clause is not a separate SQL command. It is a non-standard\nclause that can appear in many other SQL commands."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"conflict-clause     ::=  ON CONFLICT conflict-algorithm\nconflict-clause     ::=  OR conflict-algorithm\nconflict-algorithm  ::=  ROLLBACK |\n                     ABORT |\n                     FAIL |\n                     IGNORE |\n                     REPLACE\n")),(0,r.kt)("p",null,"The first form of the ON CONFLICT clause, using the keywords ON CONFLICT, is\nused in a CREATE TABLE statement. For an INSERT or UPDATE statement, the second\nform is used, with ON CONFLICT replaced by OR to make the syntax seem more\nnatural. For example, instead of INSERT ON CONFLICT IGNORE, the statement\nbecomes INSERT OR IGNORE. Although the keywords are different, the meaning of\nthe clause is the same in either form."),(0,r.kt)("p",null,"The ON CONFLICT clause specifies the algorithm that is used to resolve\nconstraint conflicts. The five algorithms are ROLLBACK, ABORT, FAIL, IGNORE, and\nREPLACE. The default algorithm is ABORT. The following is an explanation of the\nfive conflict algorithms:"),(0,r.kt)("p",null,"ROLLBACK",(0,r.kt)("br",{parentName:"p"}),"\n","When a constraint violation occurs, an immediate ROLLBACK occurs, ending the\ncurrent transaction. The command aborts and the SQLStatement instance dispatches\nan error event. If no transaction is active (other than the implied transaction\nthat is created on every command) then this algorithm works the same as ABORT."),(0,r.kt)("p",null,"ABORT",(0,r.kt)("br",{parentName:"p"}),"\n","When a constraint violation occurs, the command backs out any prior changes it\nmight have made and the SQLStatement instance dispatches an error event. No\nROLLBACK is executed, so changes from prior commands within a transaction are\npreserved. ABORT is the default behavior."),(0,r.kt)("p",null,"FAIL",(0,r.kt)("br",{parentName:"p"}),"\n","When a constraint violation occurs, the command aborts and the SQLStatement\ndispatches an error event. However, any changes to the database that the\nstatement made before encountering the constraint violation are preserved and\nare not backed out. For example, if an UPDATE statement encounters a constraint\nviolation on the 100th row that it attempts to update, then the first 99 row\nchanges are preserved but changes to rows 100 and beyond don\u2019t occur."),(0,r.kt)("p",null,"IGNORE",(0,r.kt)("br",{parentName:"p"}),"\n","When a constraint violation occurs, the one row that contains the constraint\nviolation is not inserted or changed. Aside from this row being ignored, the\ncommand continues executing normally. Other rows before and after the row that\ncontained the constraint violation continue to be inserted or updated normally.\nNo error is returned."),(0,r.kt)("p",null,"REPLACE",(0,r.kt)("br",{parentName:"p"}),"\n","When a UNIQUE constraint violation occurs, the pre-existing rows that are\ncausing the constraint violation are removed before inserting or updating the\ncurrent row. Consequently, the insert or update always occurs, and the command\ncontinues executing normally. No error is returned. If a NOT NULL constraint\nviolation occurs, the NULL value is replaced by the default value for that\ncolumn. If the column has no default value, then the ABORT algorithm is used. If\na CHECK constraint violation occurs then the IGNORE algorithm is used. When this\nconflict resolution strategy deletes rows in order to satisfy a constraint, it\ndoes not invoke delete triggers on those rows."),(0,r.kt)("p",null,"The algorithm specified in the OR clause of an INSERT or UPDATE statement\noverrides any algorithm specified in a CREATE TABLE statement. If no algorithm\nis specified in the CREATE TABLE statement or the executing INSERT or UPDATE\nstatement, the ABORT algorithm is used."),(0,r.kt)("h4",{id:"reindex"},"REINDEX"),(0,r.kt)("p",null,"The REINDEX command is used to delete and re-create one or more indices. This\ncommand is useful when the definition of a collation sequence has changed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sql-statement  ::=  REINDEX collation-name\nsql-statement  ::=  REINDEX [database-name .] ( table-name | index-name )\n")),(0,r.kt)("p",null,"In the first form, all indices in all attached databases that use the named\ncollation sequence are recreated. In the second form, when a table-name is\nspecified, all indices associated with the table are rebuilt. If an index-name\nis given, only the specified index is deleted and recreated."),(0,r.kt)("h4",{id:"comments"},"COMMENTS"),(0,r.kt)("p",null,"Comments aren't SQL commands, but they can occur in SQL queries. They are\ntreated as white space by the runtime. They can begin anywhere white space can\nbe found, including inside expressions that span multiple lines."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"comment             ::=  single-line-comment |\n                     block-comment\nsingle-line-comment ::=  -- single-line\nblock-comment       ::=  /* multiple-lines or block [*/]\n")),(0,r.kt)("p",null,"A single-line comment is indicated by two dashes. A single line comment only\nextends to the end of the current line."),(0,r.kt)("p",null,"Block comments can span any number of lines, or be embedded within a single\nline. If there is no terminating delimiter, a block comment extends to the end\nof the input. This situation is not treated as an error. A new SQL statement can\nbegin on a line after a block comment ends. Block comments can be embedded\nanywhere white space can occur, including inside expressions, and in the middle\nof other SQL statements. Block comments do not nest. Single-line comments inside\na block comment are ignored."),(0,r.kt)("h4",{id:"expressions"},"EXPRESSIONS"),(0,r.kt)("p",null,"Expressions are subcommands within other SQL blocks. The following describes the\nvalid syntax for an expression within a SQL statement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"expr            ::=  expr binary-op expr |\n                 expr [NOT] like-op expr [ESCAPE expr] |\n                 unary-op expr |\n                 ( expr ) |\n                 column-name |\n                 table-name.column-name |\n                 database-name.table-name.column-name |\n                 literal-value |\n                 parameter |\n                 function-name( expr-list | * ) |\n                 expr ISNULL |\n                 expr NOTNULL |\n                 expr [NOT] BETWEEN expr AND expr |\n                 expr [NOT] IN ( value-list ) |\n                 expr [NOT] IN ( select-statement ) |\n                 expr [NOT] IN [database-name.] table-name |\n                 [EXISTS] ( select-statement ) |\n                 CASE [expr] ( WHEN expr THEN expr )+ [ELSE expr] END |\n                 CAST ( expr AS type ) |\n                 expr COLLATE collation-name\nlike-op         ::=  LIKE | GLOB\nbinary-op       ::=  see Operators\nunary-op        ::=  see Operators\nparameter       ::=  :param-name | @param-name | ?\nvalue-list      ::=  literal-value [, literal-value]*\nliteral-value   ::=  literal-string | literal-number | literal-boolean | literal-blob | literal-null\nliteral-string  ::=  'string value'\nliteral-number  ::=  integer | number\nliteral-boolean  ::=  true | false\nliteral-blob  ::=  X'string of hexadecimal data'\nliteral-null  ::=  NULL\n")),(0,r.kt)("p",null,"An expression is any combination of values and operators that can be resolved to\na single value. Expressions can be divided into two general types, according to\nwhether they resolve to a boolean (true or false) value or whether they resolve\nto a non-boolean value."),(0,r.kt)("p",null,"In several common situations, including in a WHERE clause, a HAVING clause, the\nON expression in a JOIN clause, and a CHECK expression, the expression must\nresolve to a boolean value. The following types of expressions meet this\ncondition:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ISNULL")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"NOTNULL")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"IN ()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"EXISTS ()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"LIKE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"GLOB")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Certain functions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Certain operators (specifically comparison operators)"))),(0,r.kt)("h4",{id:"literal-values"},"Literal values"),(0,r.kt)("p",null,"A literal numeric value is written as an integer number or a floating point\nnumber. Scientific notation is supported. The . (period) character is always\nused as the decimal point."),(0,r.kt)("p",null,"A string literal is indicated by enclosing the string in single quotes '. To\ninclude a single quote within a string, put two single quotes in a row like this\nexample: ''."),(0,r.kt)("p",null,"A boolean literal is indicated by the value true or false. Literal boolean\nvalues are used with the Boolean column data type."),(0,r.kt)("p",null,"A BLOB literal is a string literal containing hexadecimal data and proceeded by\na single x or X character, such as X'53514697465'."),(0,r.kt)("p",null,"A literal value can also be the token NULL."),(0,r.kt)("h4",{id:"column-name"},"Column name"),(0,r.kt)("p",null,"A column name can be any of the names defined in the CREATE TABLE statement or\none of the following special identifiers: ROWID, OID, or ","_","ROWID","_",'. These\nspecial identifiers all describe the unique random integer key (the "row key")\nassociated with every row of every table. The special identifiers only refer to\nthe row key if the CREATE TABLE statement does not define a real column with the\nsame name. Row keys behave as read-only columns. A row key can be used anywhere\na regular column can be used, except that you cannot change the value of a row\nkey in an UPDATE or INSERT statement. The SELECT ',"*"," FROM table statement does\nnot include the row key in its result set."),(0,r.kt)("h4",{id:"select-statement"},"SELECT statement"),(0,r.kt)("p",null,"A SELECT statement can appear in an expression as either the right-hand operand\nof the IN operator, as a scalar quantity (a single result value), or as the\noperand of an EXISTS operator. When used as a scalar quantity or the operand of\nan IN operator, the SELECT can only have a single column in its result. A\ncompound SELECT statement (connected with keywords like UNION or EXCEPT) is\nallowed. With the EXISTS operator, the columns in the result set of the SELECT\nare ignored and the expression returns TRUE if one or more rows exist and FALSE\nif the result set is empty. If no terms in the SELECT expression refer to the\nvalue in the containing query, then the expression is evaluated once before any\nother processing and the result is reused as necessary. If the SELECT expression\ndoes contain variables from the outer query, known as a correlated subquery,\nthen the SELECT is re-evaluated every time it is needed."),(0,r.kt)("p",null,"When a SELECT is the right operand of the IN operator, the IN operator returns\nTRUE if the result of the left operand is equal to any of the values in the\nSELECT statement's result set. The IN operator may be preceded by the NOT\nkeyword to invert the sense of the test."),(0,r.kt)("p",null,"When a SELECT appears within an expression but is not the right operand of an IN\noperator, then the first row of the result of the SELECT becomes the value used\nin the expression. If the SELECT yields more than one result row, all rows after\nthe first are ignored. If the SELECT yields no rows, then the value of the\nSELECT is NULL."),(0,r.kt)("h4",{id:"cast-expression"},"CAST expression"),(0,r.kt)("p",null,"A CAST expression changes the data type of the value specified to the one given.\nThe type specified can be any non-empty type name that is valid for the type in\na column definition of a CREATE TABLE statement. See Data type support for\ndetails."),(0,r.kt)("h4",{id:"additional-expression-elements"},"Additional expression elements"),(0,r.kt)("p",null,"The following SQL elements can also be used in expressions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Built-in functions: Aggregate functions, Scalar functions, and Date and time\nformatting functions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Operators")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Parameters"))),(0,r.kt)("h2",{id:"built-in-functions"},"Built-in functions"),(0,r.kt)("p",null,"The built-in functions fall into three main categories:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Aggregate functions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Scalar functions")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Date and time functions"))),(0,r.kt)("p",null,"In addition to these functions, there is a special function RAISE() that is used\nto provide notification of an error in the execution of a trigger. This function\ncan only be used within the body of a CREATE TRIGGER statement. For information\non the RAISE() function, see CREATE TRIGGER ",">"," RAISE()."),(0,r.kt)("p",null,"Like all keywords in SQL, function names are not case sensitive."),(0,r.kt)("h4",{id:"aggregate-functions"},"Aggregate functions"),(0,r.kt)("p",null,"Aggregate functions perform operations on values from multiple rows. These\nfunctions are primarily used in SELECT statements in conjunction with the GROUP\nBY clause."),(0,r.kt)("table",null,(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"AVG(X)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"Returns the average value of all non-NULL X within a group. String and BLOB values that do not look like numbers are interpreted as 0. The result of AVG() is always a floating point value even if all inputs are integers."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"COUNT(X) COUNT(*)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The first form returns a count of the number of times that X is not NULL in a group. The second form (with the * argument) returns the total number of rows in the group."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"MAX(X)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"Returns the maximum value of all values in the group. The usual sort order is used to determine the maximum."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"MIN(X)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"Returns the minimum non-NULL value of all values in the group. The usual sort order is used to determine the minimum. If all values in the group are NULL, NULL is returned."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"SUM(X)"),(0,r.kt)("p",null,"TOTAL(X)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"Returns the numeric sum of all non-NULL values in the group. If all of the values are NULL then SUM() returns NULL, and TOTAL() returns 0.0. The result of TOTAL() is always a floating point value. The result of SUM() is an integer value if all non-NULL inputs are integers. If any input to SUM() is not an integer and not NULL then SUM() returns a floating point value. This value might be an approximation to the true sum."))))),(0,r.kt)("p",null,"In any of the preceding aggregate functions that take a single argument, that\nargument can be preceded by the keyword DISTINCT. In that case, duplicate\nelements are filtered before being passed into the aggregate function. For\nexample, the function call COUNT(DISTINCT x) returns the number of distinct\nvalues of column X instead of the total number of non-NULL values in column x."),(0,r.kt)("h4",{id:"scalar-functions"},"Scalar functions"),(0,r.kt)("p",null,"Scalar functions operate on values one row at a time."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ABS(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the absolute value of argument X.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"COALESCE(X, Y, ...)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a copy of the first non-NULL argument. If all arguments are NULL then NULL is returned. There must be at least two arguments.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GLOB(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"This function is used to implement the X GLOB Y syntax.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IFNULL(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a copy of the first non-NULL argument. If both arguments are NULL then NULL is returned. This function behaves the same as COALESCE().")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HEX(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"The argument is interpreted as a value of the BLOB storage type. The result is a hexadecimal rendering of the content of that value.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LAST_INSERT_ROWID()"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the row identifier (generated primary key) of the last row inserted to the database through the current SQLConnection. This value is the same as the value returned by the ",(0,r.kt)("a",{parentName:"td",href:"https://airsdk.dev/reference/actionscript/3.0/flash/data/SQLConnection.html#lastInsertRowID"},"SQLConnection.lastInsertRowID")," property.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LENGTH(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the string length of X in characters.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LIKE(X, Y ","[",", Z","]",")"),(0,r.kt)("td",{parentName:"tr",align:null},"This function is used to implement the X LIKE Y ","[","ESCAPE Z","]"," syntax of SQL. If the optional ESCAPE clause is present, then the function is invoked with three arguments. Otherwise, it is invoked with two arguments only.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LOWER(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a copy of string X with all characters converted to lower case.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LTRIM(X) LTRIM(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a string formed by removing spaces from the left side of X. If a Y argument is specified, the function removes any of the characters in Y from the left side of X.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MAX(X, Y, ...)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the argument with the maximum value. Arguments may be strings in addition to numbers. The maximum value is determined by the defined sort order. Note that MAX() is a simple function when it has 2 or more arguments but is an aggregate function when it has a single argument.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MIN(X, Y, ...)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the argument with the minimum value. Arguments may be strings in addition to numbers. The minimum value is determined by the defined sort order. Note that MIN() is a simple function when it has 2 or more arguments but is an aggregate function when it has a single argument.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NULLIF(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the first argument if the arguments are different, otherwise returns NULL.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"QUOTE(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"This routine returns a string which is the value of its argument suitable for inclusion into another SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOB storage classes are encoded as hexadecimal literals. The function is useful when writing triggers to implement undo/redo functionality.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RANDOM(","*",")"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a pseudo-random integer between -9223372036854775808 and 9223372036854775807. This random value is not crypto-strong.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RANDOMBLOB(N)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns an N-byte BLOB containing pseudo-random bytes. N should be a positive integer. This random value is not crypto-strong. If the value of N is negative a single byte is returned.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ROUND(X) ROUND(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"Rounds off the number X to Y digits to the right of the decimal point. If the Y argument is omitted, 0 is used.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"RTRIM(X) RTRIM(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a string formed by removing spaces from the right side of X. If a Y argument is specified, the function removes any of the characters in Y from the right side of X.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SUBSTR(X, Y, Z)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a substring of input string X that begins with the Y-th character and which is Z characters long. The left-most character of X is index position 1. If Y is negative the first character of the substring is found by counting from the right rather than the left.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TRIM(X) TRIM(X, Y)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a string formed by removing spaces from the right side of X. If a Y argument is specified, the function removes any of the characters in Y from the right side of X.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TYPEOF(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns the type of the expression X. The possible return values are 'null', 'integer', 'real', 'text', and 'blob'. For more information on data types see Data type support.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UPPER(X)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a copy of input string X converted to all upper-case letters.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ZEROBLOB(N)"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a BLOB containing N bytes of 0x00.")))),(0,r.kt)("h4",{id:"date-and-time-formatting-functions"},"Date and time formatting functions"),(0,r.kt)("p",null,"The date and time formatting functions are a group of scalar functions that are\nused to create formatted date and time data. Note that these functions operate\non and return string and number values. These functions are not intended to be\nused with the DATE data type. If you use these functions on data in a column\nwhose declared data type is DATE, they do not behave as expected."),(0,r.kt)("table",null,(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"DATE(T, ...)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The DATE() function returns a string containing the date in this format: YYYY-MM-DD. The first parameter (T) specifies a time string of the format found under Time formats. Any number of modifiers can be specified after the time string. The modifiers can be found under Modifiers."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"TIME(T, ...)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The TIME() function returns a string containing the time as HH:MM:SS. The first parameter (T) specifies a time string of the format found under Time formats. Any number of modifiers can be specified after the time string. The modifiers can be found under Modifiers."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"DATETIME(T, ...)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The DATETIME() function returns a string containing the date and time in YYYY-MM-DD HH:MM:SS format. The first parameter (T) specifies a time string of the format found under Time formats. Any number of modifiers can be specified after the time string. The modifiers can be found under Modifiers."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"JULIANDAY(T, ...)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The JULIANDAY() function returns a number indicating the number of days since noon in Greenwich on November 24, 4714 B.C. and the provided date. The first parameter (T) specifies a time string of the format found under Time formats. Any number of modifiers can be specified after the time string. The modifiers can be found under Modifiers."))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"STRFTIME(F, T, ...)")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The STRFTIME() routine returns the date formatted according to the format string specified as the first argument F. The format string supports the following substitutions:"),(0,r.kt)("p",null,"%d - day of month"),(0,r.kt)("p",null,"%f - fractional seconds SS.SSS"),(0,r.kt)("p",null,"%H - hour 00-24"),(0,r.kt)("p",null,"%j - day of year 001-366"),(0,r.kt)("p",null,"%J - Julian day number"),(0,r.kt)("p",null,"%m -month 01-12"),(0,r.kt)("p",null,"%M - minute 00-59"),(0,r.kt)("p",null,"%s - seconds since 1970-01-01"),(0,r.kt)("p",null,"%S - seconds 00-59"),(0,r.kt)("p",null,"%w - day of week 0-6 (sunday = 0)"),(0,r.kt)("p",null,"%W - week of year 00-53"),(0,r.kt)("p",null,"%Y - year 0000-9999"),(0,r.kt)("p",null,"%% - %"),(0,r.kt)("p",null,"The second parameter (T) specifies a time string of the format found under Time formats. Any number of modifiers can be specified after the time string. The modifiers can be found under Modifiers."))))),(0,r.kt)("h4",{id:"time-formats"},"Time formats"),(0,r.kt)("p",null,"A time string can be in any of the following formats:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DD"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DD HH:MM"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15 07:30")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DD HH:MM:SS"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15 07:30:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DD HH:MM:SS.SSS"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15 07:30:59.152")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DDTHH:MM"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15T07:30")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DDTHH:MM:SS"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15T07:30:59")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"YYYY-MM-DDTHH:MM:SS.SSS"),(0,r.kt)("td",{parentName:"tr",align:null},"2007-06-15T07:30:59.152")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HH:MM"),(0,r.kt)("td",{parentName:"tr",align:null},"07:30 (date is 2000-01-01)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HH:MM:SS"),(0,r.kt)("td",{parentName:"tr",align:null},"07:30:59 (date is 2000-01-01)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"HH:MM:SS.SSS"),(0,r.kt)("td",{parentName:"tr",align:null},"07:30:59:152 (date is 2000-01-01)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"now"),(0,r.kt)("td",{parentName:"tr",align:null},"Current date and time in Universal Coordinated Time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DDDD.DDDD"),(0,r.kt)("td",{parentName:"tr",align:null},"Julian day number as a floating-point number.")))),(0,r.kt)("p",null,'The character T in these formats is a literal character "T" separating the date\nand the time. Formats that only include a time assume the date 2001-01-01.'),(0,r.kt)("h4",{id:"modifiers"},"Modifiers"),(0,r.kt)("p",null,"The time string can be followed by zero or more modifiers that alter the date or\nalter the interpretation of the date. The available modifiers are as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NNN days"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of days to add to the time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NNN hours"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of hours to add to the time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NNN minutes"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of minutes to add to the time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NNN.NNNN seconds"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of seconds and milliseconds to add to the time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NNN months"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of months to add to the time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NNN years"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of years to add to the time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"start of month"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift time backwards to the start of the month.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"start of year"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift time backwards to the start of the year.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"start of day"),(0,r.kt)("td",{parentName:"tr",align:null},"Shift time backwards to the start of the day.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"weekday N"),(0,r.kt)("td",{parentName:"tr",align:null},"Forwards the time to the specified weekday. (0 = Sunday, 1 = Monday, and so forth).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"localtime"),(0,r.kt)("td",{parentName:"tr",align:null},"Converts the date to local time.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"utc"),(0,r.kt)("td",{parentName:"tr",align:null},"Converts the date to Universal Coordinated Time.")))),(0,r.kt)("h2",{id:"operators"},"Operators"),(0,r.kt)("p",null,"SQL supports a large selection of operators, including common operators that\nexist in most programming languages, as well as several operators that are\nunique to SQL."),(0,r.kt)("h4",{id:"common-operators"},"Common operators"),(0,r.kt)("p",null,"The following binary operators are allowed in a SQL block and are listed in\norder from highest to lowest precedence:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"*    /    %\n+    -\n<< >> &     |\n< >=   > >=\n=    ==   !=   <> IN\nAND\nOR\n")),(0,r.kt)("p",null,"Supported unary prefix operators are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," !    ~    NOT\n")),(0,r.kt)("p",null,"The COLLATE operator can be thought of as a unary postfix operator. The COLLATE\noperator has the highest precedence. It always binds more tightly than any\nprefix unary operator or any binary operator."),(0,r.kt)("p",null,"Note that there are two variations of the equals and not equals operators.\nEquals can be either = or ==. The not-equals operator can be either != or \\<",">","."),(0,r.kt)("p",null,"The ","|","|"," operator is the string concatenation operator\u2014it joins together the two\nstrings of its operands."),(0,r.kt)("p",null,"The operator % outputs the remainder of its left operand modulo its right\noperand."),(0,r.kt)("p",null,"The result of any binary operator is a numeric value, except for the ","|","|","\nconcatenation operator which gives a string result."),(0,r.kt)("h4",{id:"sql-operators"},"SQL operators"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"LIKE")),(0,r.kt)("p",null,"The LIKE operator does a pattern matching comparison."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"expr     ::=  (column-name | expr) LIKE pattern\npattern  ::=  '[ string | % | _ ]'\n")),(0,r.kt)("p",null,"The operand to the right of the LIKE operator contains the pattern, and the\nleft-hand operand contains the string to match against the pattern. A percent\nsymbol (%) in the pattern is a wildcard character\u2014it matches any sequence of\nzero or more characters in the string. An underscore (","_",") in the pattern matches\nany single character in the string. Any other character matches itself or its\nlower/upper case equivalent, that is, matches are performed in a\ncase-insensitive manner. (Note: the database engine only understands upper/lower\ncase for 7-bit Latin characters. Consequently, the LIKE operator is case\nsensitive for 8-bit iso8859 characters or UTF-8 characters. For example, the\nexpression 'a' LIKE 'A' is TRUE but '\xe6' LIKE '\xc6' is FALSE). Case sensitivity for\nLatin characters can be changed using the SQLConnection.caseSensitiveLike\nproperty."),(0,r.kt)("p",null,"If the optional ESCAPE clause is present, then the expression following the\nESCAPE keyword must evaluate to a string consisting of a single character. This\ncharacter may be used in the LIKE pattern to match literal percent or underscore\ncharacters. The escape character followed by a percent symbol, underscore or\nitself matches a literal percent symbol, underscore or escape character in the\nstring, respectively."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"GLOB")),(0,r.kt)("p",null,"The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for\nits wildcards. Unlike LIKE, GLOB is case sensitive."),(0,r.kt)("p",null,"IN"),(0,r.kt)("p",null,"The IN operator calculates whether its left operand is equal to one of the\nvalues in its right operand (a set of values in parentheses)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"in-expr         ::=  expr [NOT] IN ( value-list ) |\n                 expr [NOT] IN ( select-statement ) |\n                 expr [NOT] IN [database-name.] table-name\nvalue-list      ::=  literal-value [, literal-value]*\n")),(0,r.kt)("p",null,"The right operand can be a set of comma-separated literal values, or it can be\nthe result of a SELECT statement. See SELECT statements in expressions for an\nexplanation and limitations on using a SELECT statement as the right-hand\noperand of the IN operator."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"BETWEEN...AND")),(0,r.kt)("p",null,"The BETWEEN...AND operator is equivalent to using two expressions with the ",">","=\nand \\<= operators. For example, the expression x BETWEEN y AND z is equivalent\nto x ",">","= y AND x \\<= z."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOT")),(0,r.kt)("p",null,"The NOT operator is a negation operator. The GLOB, LIKE, and IN operators may be\npreceded by the NOT keyword to invert the sense of the test (in other words, to\ncheck that a value does not match the indicated pattern)."),(0,r.kt)("h2",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"A parameter specifies a placeholder in the expression for a literal value that\nis filled in at runtime by assigning a value to the SQLStatement.parameters\nassociative array. Parameters can take three forms:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"?"),(0,r.kt)("td",{parentName:"tr",align:null},"A question mark indicates an indexed parameter. Parameters are assigned numerical (zero-based) index values according to their order in the statement.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},":AAAA"),(0,r.kt)("td",{parentName:"tr",align:null},"A colon followed by an identifier name holds a spot for a named parameter with the name AAAA. Named parameters are also numbered according to their order in the SQL statement. To avoid confusion, it is best to avoid mixing named and numbered parameters.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"@AAAA"),(0,r.kt)("td",{parentName:"tr",align:null},'An "at sign" is equivalent to a colon.')))),(0,r.kt)("h2",{id:"unsupported-sql-features"},"Unsupported SQL features"),(0,r.kt)("p",null,"The following is a list of the standard SQL elements that are not supported in\nAdobe AIR:"),(0,r.kt)("p",null,"FOREIGN KEY constraints",(0,r.kt)("br",{parentName:"p"}),"\n","FOREIGN KEY constraints are parsed but are not enforced."),(0,r.kt)("p",null,"Triggers",(0,r.kt)("br",{parentName:"p"}),"\n","FOR EACH STATEMENT triggers are not supported (all triggers must be FOR EACH\nROW). INSTEAD OF triggers are not supported on tables (INSTEAD OF triggers are\nonly allowed on views). Recursive triggers\u2014triggers that trigger themselves\u2014are\nnot supported."),(0,r.kt)("p",null,"ALTER TABLE",(0,r.kt)("br",{parentName:"p"}),"\n","Only the RENAME TABLE and ADD COLUMN variants of the ALTER TABLE command are\nsupported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER\nCOLUMN, ADD CONSTRAINT, and so forth are ignored."),(0,r.kt)("p",null,"Nested transactions",(0,r.kt)("br",{parentName:"p"}),"\n","Only a single active transaction is allowed."),(0,r.kt)("p",null,"RIGHT and FULL OUTER JOIN",(0,r.kt)("br",{parentName:"p"}),"\n","RIGHT OUTER JOIN or FULL OUTER JOIN are not supported."),(0,r.kt)("p",null,"Updateable VIEW",(0,r.kt)("br",{parentName:"p"}),"\n","A view is read only. You may not execute a DELETE, INSERT, or UPDATE statement\non a view. An INSTEAD OF trigger that fires on an attempt to DELETE, INSERT, or\nUPDATE a view is supported and can be used to update supporting tables in the\nbody of the trigger."),(0,r.kt)("p",null,"GRANT and REVOKE",(0,r.kt)("br",{parentName:"p"}),"\n","A database is an ordinary disk file; the only access permissions that can be\napplied are the normal file access permissions of the underlying operating\nsystem. The GRANT and REVOKE commands commonly found on client/server RDBMSes\nare not implemented."),(0,r.kt)("p",null,"The following SQL elements and SQLite features are supported in some SQLite\nimplementations, but are not supported in Adobe AIR. Most of this functionality\nis available through methods of the SQLConnection class:"),(0,r.kt)("p",null,"Transaction-related SQL elements (BEGIN, END, COMMIT, ROLLBACK)",(0,r.kt)("br",{parentName:"p"}),"\n","This functionality is available through the transaction-related methods of the\nSQLConnection class: SQLConnection.begin(), SQLConnection.commit(), and\nSQLConnection.rollback()."),(0,r.kt)("p",null,"ANALYZE",(0,r.kt)("br",{parentName:"p"}),"\n","This functionality is available through the SQLConnection.analyze() method."),(0,r.kt)("p",null,"ATTACH",(0,r.kt)("br",{parentName:"p"}),"\n","This functionality is available through the SQLConnection.attach() method."),(0,r.kt)("p",null,"COPY",(0,r.kt)("br",{parentName:"p"}),"\n","This statement is not supported."),(0,r.kt)("p",null,"CREATE VIRTUAL TABLE",(0,r.kt)("br",{parentName:"p"}),"\n","This statement is not supported."),(0,r.kt)("p",null,"DETACH",(0,r.kt)("br",{parentName:"p"}),"\n","This functionality is available through the SQLConnection.detach() method."),(0,r.kt)("p",null,"PRAGMA",(0,r.kt)("br",{parentName:"p"}),"\n","This statement is not supported."),(0,r.kt)("p",null,"VACUUM",(0,r.kt)("br",{parentName:"p"}),"\n","This functionality is available through the SQLConnection.compact() method."),(0,r.kt)("p",null,"System table access is not available",(0,r.kt)("br",{parentName:"p"}),"\n",'The system tables including sqlite_master and other tables with the "sqlite',"_",'"\nprefix are not available in SQL statements. The runtime includes a schema API\nthat provides an object-oriented way to access schema data. For more information\nsee the SQLConnection.loadSchema() method.'),(0,r.kt)("p",null,"Regular-expression functions (MATCH() and REGEX())",(0,r.kt)("br",{parentName:"p"}),"\n","These functions are not available in SQL statements."),(0,r.kt)("p",null,"The following functionality differs between many SQLite implementations and\nAdobe AIR:"),(0,r.kt)("p",null,"Indexed statement parameters",(0,r.kt)("br",{parentName:"p"}),"\n","In many implementations indexed statement parameters are one-based. However, in\nAdobe AIR indexed statement parameters are zero-based (that is, the first\nparameter is given the index 0, the second parameter is given the index 1, and\nso forth."),(0,r.kt)("p",null,"INTEGER PRIMARY KEY column definitions",(0,r.kt)("br",{parentName:"p"}),"\n","In many implementations, only columns that are defined exactly as INTEGER\nPRIMARY KEY are used as the actual primary key column for a table. In those\nimplementations, using another data type that is usually a synonym for INTEGER\n(such as int) does not cause the column to be used as the internal primary key.\nHowever, in Adobe AIR, the int data type (and other INTEGER synonyms) are\nconsidered exactly equivalent to INTEGER. Consequently, a column defined as int\nPRIMARY KEY is used as the internal primary key for a table. For more\ninformation, see the sections CREATE TABLE and Column affinity."),(0,r.kt)("h2",{id:"additional-sql-features"},"Additional SQL features"),(0,r.kt)("p",null,"The following column affinity types are not supported by default in SQLite, but\nare supported in Adobe AIR (Note that, like all keywords in SQL, these data type\nnames are not case-sensitive):"),(0,r.kt)("p",null,"Boolean",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the Boolean class."),(0,r.kt)("p",null,"Date",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the Date class."),(0,r.kt)("p",null,"int",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the int class (equivalent to the INTEGER column affinity)."),(0,r.kt)("p",null,"Number",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the Number class (equivalent to the REAL column affinity)."),(0,r.kt)("p",null,"Object",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the Object class or any subclass that can be serialized and\ndeserialized using AMF3. (This includes most classes including custom classes,\nbut excludes some classes including display objects and objects that include\ndisplay objects as properties.)"),(0,r.kt)("p",null,"String",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the String class (equivalent to the TEXT column affinity)."),(0,r.kt)("p",null,"XML",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the ActionScript (E4X) XML class."),(0,r.kt)("p",null,"XMLList",(0,r.kt)("br",{parentName:"p"}),"\n","corresponding to the ActionScript (E4X) XMLList class."),(0,r.kt)("p",null,"The following literal values are not supported by default in SQLite, but are\nsupported in Adobe AIR:"),(0,r.kt)("p",null,"true",(0,r.kt)("br",{parentName:"p"}),"\n","used to represent the literal boolean value true, for working with BOOLEAN\ncolumns."),(0,r.kt)("p",null,"false",(0,r.kt)("br",{parentName:"p"}),"\n","used to represent the literal boolean value false, for working with BOOLEAN\ncolumns."))}p.isMDXComponent=!0}}]);