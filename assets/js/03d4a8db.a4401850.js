"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[44533],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),h=i,c=m["".concat(s,".").concat(h)]||m[h]||f[h]||r;return n?a.createElement(c,o(o({ref:t},d),{},{components:n})):a.createElement(c,o({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},83678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>f,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={sidebar_position:2},o="ByteArray example: Reading a .zip file",l={unversionedId:"development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file",id:"development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file",title:"ByteArray example: Reading a .zip file",description:"This example demonstrates how to read a simple .zip file containing several",source:"@site/docs/development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file.md",sourceDirName:"development/files-and-data/working-with-bytearrays",slug:"/development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file",permalink:"/docs/development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file",draft:!1,editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/files-and-data/working-with-bytearrays/bytearray-example-reading-a-zip-file.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"mainSidebar",previous:{title:"Reading and writing a ByteArray",permalink:"/docs/development/files-and-data/working-with-bytearrays/reading-and-writing-a-bytearray"},next:{title:"Networking and communication",permalink:"/docs/development/networking-and-communication/"}},s={},p=[],d={toc:p},m="wrapper";function f(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"bytearray-example-reading-a-zip-file"},"ByteArray example: Reading a .zip file"),(0,i.kt)("p",null,"This example demonstrates how to read a simple .zip file containing several\nfiles of different types. It does so by extracting relevant data from the\nmetadata for each file, uncompressing each file into a ByteArray and writing the\nfile to the desktop."),(0,i.kt)("p",null,"The general structure of a .zip file is based on the specification by PKWARE\nInc., which is maintained at\n",(0,i.kt)("a",{parentName:"p",href:"http://www.pkware.com/documents/casestudies/APPNOTE.TXT"},"http://www.pkware.com/documents/casestudies/APPNOTE.TXT"),". First is a file\nheader and file data for the first file in the .zip archive, followed by a file\nheader and file data pair for each additional file. (The structure of the file\nheader is described later.) Next, the .zip file optionally includes a data\ndescriptor record (usually when the output zip file was created in memory rather\nthan saved to a disk). Next are several additional optional elements: archive\ndecryption header, archive extra data record, central directory structure, Zip64\nend of central directory record, Zip64 end of central directory locator, and end\nof central directory record."),(0,i.kt)("p",null,"The code in this example is written to only parse zip files that do not contain\nfolders and it does not expect data descriptor records. It ignores all\ninformation following the last file data."),(0,i.kt)("p",null,"The format of the file header for each file is as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"file header signature"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"required version"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"general-purpose bit flag"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"compression method"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes (8=DEFLATE; 0=UNCOMPRESSED)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"last modified file time"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"last modified file date"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"crc-32"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"compressed size"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"uncompressed size"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"file name length"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"extra field length"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"file name"),(0,i.kt)("td",{parentName:"tr",align:null},"variable")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"extra field"),(0,i.kt)("td",{parentName:"tr",align:null},"variable")))),(0,i.kt)("p",null,"Following the file header is the actual file data, which can be either\ncompressed or uncompressed, depending on the compression method flag. The flag\nis 0 (zero) if the file data is uncompressed, 8 if the data is compressed using\nthe DEFLATE algorithm, or another value for other compression algorithms."),(0,i.kt)("p",null,"The user interface for this example consists of a label and a text area (\n",(0,i.kt)("inlineCode",{parentName:"p"},"taFiles"),"). The application writes the following information to the text area\nfor each file it encounters in the .zip file: the file name, the compressed\nsize, and the uncompressed size. The following MXML document defines the user\ninterface for the Flex version of the application:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'<?xml version="1.0" encoding="utf-8"?>\n<mx:WindowedApplication xmlns:mx="https://www.adobe.com/2006/mxml" layout="vertical" creationComplete="init();">\n    <mx:Script>\n    <![CDATA[\n        // The application code goes here\n    ]]>\n    </mx:Script>\n    <mx:Form>\n        <mx:FormItem label="Output">\n            <mx:TextArea id="taFiles" width="320" height="150"/>\n        </mx:FormItem>\n    </mx:Form>\n</mx:WindowedApplication>\n')),(0,i.kt)("p",null,"The beginning of the program performs the following tasks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Imports the required classes"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"import flash.filesystem.*;\nimport flash.utils.ByteArray;\nimport flash.events.Event;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Defines the user interface for Flash"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'import fl.controls.*;\n\n//requires TextArea and Label components in the Library\nvar taFiles = new TextArea();\nvar output = new Label();\ntaFiles.setSize(320, 150);\ntaFiles.move(10, 30);\noutput.move(10, 10);\noutput.width = 150;\noutput.text = "Contents of HelloAir.zip";\naddChild(taFiles);\naddChild(output);\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Defines the ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," ByteArray"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"var bytes:ByteArray = new ByteArray();\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Defines variables to store metadata from the file header"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"// variables for reading fixed portion of file header\nvar fileName:String = new String();\nvar flNameLength:uint;\nvar xfldLength:uint;\nvar offset:uint;\nvar compSize:uint;\nvar uncompSize:uint;\nvar compMethod:int;\nvar signature:int;\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Defines File ( ",(0,i.kt)("inlineCode",{parentName:"p"},"zfile"),") and FileStream ( ",(0,i.kt)("inlineCode",{parentName:"p"},"zStream"),') objects to represent the\n.zip file, and specifies the location of the .zip file from which the files\nare extracted\u2014a file named "HelloAIR.zip" in the desktop directory.'),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'// File variables for accessing .zip file\nvar zfile:File = File.desktopDirectory.resolvePath("HelloAIR.zip");\nvar zStream:FileStream = new FileStream();\n')))),(0,i.kt)("p",null,"In Flex, the program code starts in the ",(0,i.kt)("inlineCode",{parentName:"p"},"init()")," method, which is called as the\n",(0,i.kt)("inlineCode",{parentName:"p"},"creationComplete")," handler for the root ",(0,i.kt)("inlineCode",{parentName:"p"},"mx:WindowedApplication")," tag."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// for Flex\nprivate function init():void\n{\n")),(0,i.kt)("p",null,"The program begins by opening the .zip file in READ mode."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    zStream.open(zfile, FileMode.READ);\n")),(0,i.kt)("p",null,"It then sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"endian")," property of ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"LITTLE_ENDIAN")," to indicate\nthat the byte order of numeric fields has the least significant byte first."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    bytes.endian = Endian.LITTLE_ENDIAN;\n")),(0,i.kt)("p",null,"Next, a ",(0,i.kt)("inlineCode",{parentName:"p"},"while()")," statement begins a loop that continues until the current\nposition in the file stream is greater than or equal to the size of the file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"while (zStream.position < zfile.size)\n{\n")),(0,i.kt)("p",null,"The first statement inside the loop reads the first 30 bytes of the file stream\ninto the ByteArray ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),". The first 30 bytes make up the fixed-size part of\nthe first file header."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    // read fixed metadata portion of local file header\n    zStream.readBytes(bytes, 0, 30);\n")),(0,i.kt)("p",null,"Next, the code reads an integer ( ",(0,i.kt)("inlineCode",{parentName:"p"},"signature"),") from the first bytes of the\n30-byte header. The ZIP format definition specifies that the signature for every\nfile header is the hexadecimal value ",(0,i.kt)("inlineCode",{parentName:"p"},"0x04034b50")," ; if the signature is\ndifferent it means that the code has moved beyond the file portion of the .zip\nfile and there are no more files to extract. In that case the code exits the\n",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loop immediately rather than waiting for the end of the byte array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    bytes.position = 0;\n    signature = bytes.readInt();\n    // if no longer reading data files, quit\n    if (signature != 0x04034b50)\n    {\n        break;\n    }\n")),(0,i.kt)("p",null,"The next part of the code reads the header byte at offset position 8 and stores\nthe value in the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"compMethod"),". This byte contains a value indicating\nthe compression method that was used to compress this file. Several compression\nmethods are allowed, but in practice nearly all .zip files use the DEFLATE\ncompression algorithm. If the current file is compressed with DEFLATE\ncompression, ",(0,i.kt)("inlineCode",{parentName:"p"},"compMethod")," is 8; if the file is uncompressed, ",(0,i.kt)("inlineCode",{parentName:"p"},"compMethod")," is 0."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    bytes.position = 8;\n    compMethod = bytes.readByte();  // store compression method (8 == Deflate)\n")),(0,i.kt)("p",null,"Following the first 30 bytes is a variable-length portion of the header that\ncontains the file name and, possibly, an extra field. The variable ",(0,i.kt)("inlineCode",{parentName:"p"},"offset"),"\nstores the size of this portion. The size is calculated by adding the file name\nlength and extra field length, read from the header at offsets 26 and 28."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    offset = 0;    // stores length of variable portion of metadata\n    bytes.position = 26;  // offset to file name length\n    flNameLength = bytes.readShort();    // store file name\n    offset += flNameLength;     // add length of file name\n    bytes.position = 28;    // offset to extra field length\n    xfldLength = bytes.readShort();\n    offset += xfldLength;    // add length of extra field\n")),(0,i.kt)("p",null,"Next the program reads the variable-length portion of the file header for the\nnumber of bytes stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"offset")," variable."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    // read variable length bytes between fixed-length header and compressed file data\n    zStream.readBytes(bytes, 30, offset);\n")),(0,i.kt)("p",null,"The program reads the file name from the variable length portion of the header\nand displays it in the text area along with the compressed (zipped) and\nuncompressed (original) sizes of the file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'    // Flash version\n    bytes.position = 30;\n    fileName = bytes.readUTFBytes(flNameLength); // read file name\n    taFiles.appendText(fileName + "\\n"); // write file name to text area\n    bytes.position = 18;\n    compSize = bytes.readUnsignedInt();  // store size of compressed portion\n    taFiles.appendText("\\tCompressed size is: " + compSize + \'\\n\');\n    bytes.position = 22;  // offset to uncompressed size\n    uncompSize = bytes.readUnsignedInt();  // store uncompressed size\n    taFiles.appendText("\\tUncompressed size is: " + uncompSize + \'\\n\');\n\n\n    // Flex version\n    bytes.position = 30;\n    fileName = bytes.readUTFBytes(flNameLength); // read file name\n    taFiles.text += fileName + "\\n"; // write file name to text area\n    bytes.position = 18;\n    compSize = bytes.readUnsignedInt();  // store size of compressed portion\n    taFiles.text += "\\tCompressed size is: " + compSize + \'\\n\';\n    bytes.position = 22;  // offset to uncompressed size\n    uncompSize = bytes.readUnsignedInt();  // store uncompressed size\n    taFiles.text += "\\tUncompressed size is: " + uncompSize + \'\\n\';\n')),(0,i.kt)("p",null,"The example reads the rest of the file from the file stream into ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," for the\nlength specified by the compressed size, overwriting the file header in the\nfirst 30 bytes. The compressed size is accurate even if the file is not\ncompressed because in that case the compressed size is equal to the uncompressed\nsize of the file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// read compressed file to offset 0 of bytes; for uncompressed files\n// the compressed and uncompressed size is the same\nif (compSize == 0) continue;\nzStream.readBytes(bytes, 0, compSize);\n")),(0,i.kt)("p",null,"Next, the example uncompresses the compressed file and calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"outfile()"),"\nfunction to write it to the output file stream. It passes ",(0,i.kt)("inlineCode",{parentName:"p"},"outfile()")," the file\nname and the byte array containing the file data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    if (compMethod == 8) // if file is compressed, uncompress\n    {\n        bytes.uncompress(CompressionAlgorithm.DEFLATE);\n    }\n    outFile(fileName, bytes);   // call outFile() to write out the file\n")),(0,i.kt)("p",null,"In the previously mentioned example,\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes.uncompress(CompressionAlgorithm.DEFLATE)")," will work only in AIR\napplications. To get deflated data uncompressed for both AIR and Flash Player,\ninvoke ByteArray's ",(0,i.kt)("inlineCode",{parentName:"p"},"inflate()")," function."),(0,i.kt)("p",null,"The closing braces indicate the end of the ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loop, and of the ",(0,i.kt)("inlineCode",{parentName:"p"},"init()"),"\nmethod and the Flex application code, except for the ",(0,i.kt)("inlineCode",{parentName:"p"},"outFile()")," method.\nExecution loops back to the beginning of the ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," loop and continues\nprocessing the next bytes in the .zip file\u2014either extracting another file or\nending processing of the .zip file if the last file has been processed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    } // end of while loop\n} // for Flex version, end of init() method and application\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"outfile()")," function opens an output file in WRITE mode on the desktop,\ngiving it the name supplied by the ",(0,i.kt)("inlineCode",{parentName:"p"},"filename")," parameter. It then writes the file\ndata from the ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," parameter to the output file stream ( ",(0,i.kt)("inlineCode",{parentName:"p"},"outStream"),") and\ncloses the file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Flash version\nfunction outFile(fileName:String, data:ByteArray):void\n{\n    var outFile:File = File.desktopDirectory; // destination folder is desktop\n    outFile = outFile.resolvePath(fileName);  // name of file to write\n    var outStream:FileStream = new FileStream();\n    // open output file stream in WRITE mode\n    outStream.open(outFile, FileMode.WRITE);\n    // write out the file\n    outStream.writeBytes(data, 0, data.length);\n    // close it\n    outStream.close();\n}\n\nprivate function outFile(fileName:String, data:ByteArray):void\n{\n    var outFile:File = File.desktopDirectory; // dest folder is desktop\n    outFile = outFile.resolvePath(fileName);  // name of file to write\n    var outStream:FileStream = new FileStream();\n    // open output file stream in WRITE mode\n    outStream.open(outFile, FileMode.WRITE);\n    // write out the file\n    outStream.writeBytes(data, 0, data.length);\n    // close it\n    outStream.close();\n}\n")))}f.isMDXComponent=!0}}]);