"use strict";(self.webpackChunkairsdk_dev=self.webpackChunkairsdk_dev||[]).push([[24591],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),o=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},p=function(e){var n=o(e.components);return i.createElement(l.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=o(t),c=r,g=u["".concat(l,".").concat(c)]||u[c]||h[c]||a;return t?i.createElement(g,d(d({ref:n},p),{},{components:t})):i.createElement(g,d({ref:n},p))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,d=new Array(a);d[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:r,d[1]=s;for(var o=2;o<a;o++)d[o]=t[o];return i.createElement.apply(null,d)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},18097:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var i=t(87462),r=(t(67294),t(3905));const a={},d="Defining winding rules",s={unversionedId:"development/display/using-the-drawing-api/defining-winding-rules",id:"development/display/using-the-drawing-api/defining-winding-rules",title:"Defining winding rules",description:'The enhanced drawing API also introduces the concept of path "winding": the',source:"@site/docs/development/display/using-the-drawing-api/defining-winding-rules.md",sourceDirName:"development/display/using-the-drawing-api",slug:"/development/display/using-the-drawing-api/defining-winding-rules",permalink:"/docs/development/display/using-the-drawing-api/defining-winding-rules",draft:!1,editUrl:"https://github.com/airsdk/airsdk.dev/edit/main/docs/development/display/using-the-drawing-api/defining-winding-rules.md",tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"About using drawTriangles()",permalink:"/docs/development/display/using-the-drawing-api/about-using-drawtriangles"},next:{title:"Drawing API example: Algorithmic Visual Generator",permalink:"/docs/development/display/using-the-drawing-api/drawing-api-example-algorithmic-visual-generator"}},l={},o=[{value:"Winding rule names",id:"winding-rule-names",level:2},{value:"Using winding rules",id:"using-winding-rules",level:2}],p={toc:o},u="wrapper";function h(e){let{components:n,...a}=e;return(0,r.kt)(u,(0,i.Z)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"defining-winding-rules"},"Defining winding rules"),(0,r.kt)("p",null,'The enhanced drawing API also introduces the concept of path "winding": the\ndirection for a path. The winding for a path is either positive (clockwise) or\nnegative (counter-clockwise). The order in which the renderer interprets the\ncoordinates provided by the vector for the data parameter determines the\nwinding.'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Positive and negative winding",src:t(8319).Z,width:"330",height:"231"})),(0,r.kt)("p",null,"Positive and negative winding"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A.")," Arrows indicate drawing direction"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"B.")," Positively wound (clockwise)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"C.")," Negatively wound (counter-clockwise)"),(0,r.kt)("p",null,"Additionally, notice that the ",(0,r.kt)("inlineCode",{parentName:"p"},"Graphics.drawPath()"),' method has an optional third\nparameter called "winding":'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'drawPath(commands:Vector.<int>, data:Vector.<Number>, winding:String = "evenOdd"):void\n')),(0,r.kt)("p",null,"In this context, the third parameter is a string or a constant that specifies\nthe winding or fill rule for intersecting paths. (The constant values are\ndefined in the GraphicsPathWinding class as ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphicsPathWinding.EVEN_ODD")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},"GraphicsPathWinding.NON_ZERO"),".) The winding rule is important when paths\nintersect."),(0,r.kt)("p",null,"The even-odd rule is the standard winding rule and is the rule used by the\nlegacy drawing API. The Even-odd rule is also the default rule for the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Graphics.drawPath()")," method. With the even-odd winding rule, any intersecting\npaths alternate between open and closed fills. If two squares drawn with the\nsame fill intersect, the area in which the intersection occurs is filled.\nGenerally, adjacent areas are neither both filled nor both unfilled."),(0,r.kt)("p",null,"The non-zero rule, on the other hand, depends on winding (drawing direction) to\ndetermine whether areas defined by intersecting paths are filled. When paths of\nopposite winding intersect, the area defined is unfilled, much like with\neven-odd. For paths of the same winding, the area that would be unfilled is\nfilled:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Winding rules for intersecting areas",src:t(77820).Z,width:"294",height:"251"})),(0,r.kt)("p",null,"Winding rules for intersecting areas"),(0,r.kt)("p",null,"A.",(0,r.kt)("br",{parentName:"p"}),"\n","Even-odd winding rule"),(0,r.kt)("p",null,"B.",(0,r.kt)("br",{parentName:"p"}),"\n","Non-zero winding rule"),(0,r.kt)("h2",{id:"winding-rule-names"},"Winding rule names"),(0,r.kt)("p",null,"The names refer to a more specific rule that defines how these fills are\nmanaged. Positively wound paths are assigned a value of +1; negatively wound\npaths are assigned a value of -1. Starting from a point within an enclosed area\nof a shape, draw a line from that point extending out indefinitely. The number\nof times that line crosses a path, and the combined values of those paths, are\nused to determine the fill. For even-odd winding, the count of times the line\ncrosses a path is used. When the count is odd, the area is filled. For even\ncounts, the area is unfilled. For non-zero winding, the values assigned to the\npaths are used. When the combined values of the path are not 0, the area is\nfilled. When the combined value is 0, the area is unfilled."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Winding rule counts and fills",src:t(7870).Z,width:"334",height:"254"})),(0,r.kt)("p",null,"Winding rule counts and fills"),(0,r.kt)("p",null,"A.",(0,r.kt)("br",{parentName:"p"}),"\n","Even-odd winding rule"),(0,r.kt)("p",null,"B.",(0,r.kt)("br",{parentName:"p"}),"\n","Non-zero winding rule"),(0,r.kt)("h2",{id:"using-winding-rules"},"Using winding rules"),(0,r.kt)("p",null,"These fill rules are complicated, but in some situations they are necessary. For\nexample, consider drawing a star shape. With the standard even-odd rule, the\nshape would require ten different lines. With the non-zero winding rule, those\nten lines are reduced to five. Here is the ActionScript for a star with five\nlines and a non-zero winding rule:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"graphics.beginFill(0x60A0FF);\ngraphics.drawPath( Vector.<int>([1,2,2,2,2]),  Vector.<Number>([66,10, 23,127, 122,50, 10,49, 109,127]),   GraphicsPathWinding.NON_ZERO);\n")),(0,r.kt)("p",null,"And here is the star shape:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"A star shape using different winding",src:t(33724).Z,width:"368",height:"155"})),(0,r.kt)("p",null,"A star shape using different winding rules"),(0,r.kt)("p",null,"A.",(0,r.kt)("br",{parentName:"p"}),"\n","Even-odd 10 lines"),(0,r.kt)("p",null,"B.",(0,r.kt)("br",{parentName:"p"}),"\n","Even-odd 5 lines"),(0,r.kt)("p",null,"C.",(0,r.kt)("br",{parentName:"p"}),"\n","Non-zero 5 lines"),(0,r.kt)("p",null,"And, as images are animated or used as textures on three-dimensional objects and\noverlap, the winding rules become more important."))}h.isMDXComponent=!0},7870:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/gv_winding_exp-45638df509115885d6eb7bdde6263295.png"},8319:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/gv_winding_positive_negative-2273656895013a65d61fce5e9f74b4e8.png"},77820:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/gv_winding_rules_evenodd_nonzero-53690e79738530bb5fcee3bf0a90d51f.png"},33724:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/gv_winding_star-4a7d80735dd08cc12f3d7d90e317b847.png"}}]);